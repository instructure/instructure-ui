{"description":"\n## emotion\n\nThe [Emotion design library's](https://emotion.sh/) implementation in Instructure UI.\n\nWith this framework, each UI component can be used in isolation and support multiple themes, including dynamic themes provided at runtime, while still working within a system of components that use a shared global theme.\n\n### Motivation\n\n1. Two-tiered theme variable system: system-wide variables + component level variables. With this variable system, components can be themed, tested, and rendered in isolation from the rest of the system, and we can mitigate issues that may arise with system-wide theme updates.\n\n2. Runtime theme application and definition: to apply user/account level themes without using the CSS cascade.\n\n3. Prevent CSS Cascade bugs: All components should specify variants via props or component level theme variables only (no className or style overrides) with a clear API and should not rely on any external styles.\n\n4. Theme variables should be accessible in JS.\n\n5. All component styles should be scoped to the component.\n\n6. Pre-render/server-side render support (inline critical CSS).\n\n7. Use a popular, well maintained and broadly adopted JS design and theming library that supports runtime theme switching ([Emotion](https://emotion.sh/)).\n\n### Usage\n\nMake a component themeable with the [withStyle](#withStyle) decorator. It adds a `makeStyles` function and the generated `styles` object to the decorated Component's props.\n\nImport the style generator (`generateStyle`) from `styles.js` and the component theme generator (`generateComponentTheme`) from `theme.js`, and pass them to the decorator.\n\nCall the `makeStyles` method (available on `this.props`) in the `componentDidMount` and `componentDidUpdate` lifecycle methods to generate the styles object and to keep it properly recalculated on every change.\n\nIn the `render` method, use emotion's `css={this.props.styles.componentName}` syntax to add styles.\n\n```jsx\n---\ntype: code\n---\n// Button/index.js\n\n/** @jsx jsx */\nimport { withStyle, jsx } from '@instructure/emotion'\nimport generateStyle from './styles'\nimport generateComponentTheme from './theme'\n\n@withStyle(generateStyle, generateComponentTheme)\nclass Button extends React.Component {\n  static propTypes = {\n    // eslint-disable-next-line react/require-default-props\n    makeStyles: PropTypes.func,\n    // eslint-disable-next-line react/require-default-props\n    styles: PropTypes.object\n  }\n\n  componentDidMount() {\n    this.props.makeStyles()\n  }\n\n  componentDidUpdate() {\n    this.props.makeStyles()\n  }\n\n  render() {\n    const { propVal1, styles, ...props } = this.props\n\n    return (\n      <button css={styles.button}>\n        <svg css={styles.icon}>...</svg>\n        ...\n      </button>\n    )\n  }\n}\n\nexport { Button }\nexport default Button\n```\n\nThemeable components inject their themed styles into the document when they are mounted.\n\nA themeable componentâ€™s theme can be configured by wrapping it in an [InstUISettingsProvider](#InstUISettingsProvider) component, and/or set explicitly via its `themeOverride` prop.\n\n#### themeOverride prop\n\nThe themeable components accept a `themeOverride` prop which lets you override it's component theme object. It accepts an override object or a function, which has the current `componentTheme` as its parameter.\n\n**See more on the [withStyle](#withStyle/#applying-themes) and [Using theme overrides](/#using-theme-overrides) doc pages for more info.**\n\n```js\n---\ntype: example\n---\n<div>\n  <Button color='primary' themeOverride={{ primaryBackground: \"purple\" }}>\n    Button\n  </Button>\n  <Button\n    color='primary'\n    margin=\"0 0 0 small\"\n    themeOverride={(componentTheme) => ({\n      primaryBackground: componentTheme.successBackground,\n      primaryBorderColor: componentTheme.successBorderColor\n    })}\n  >\n    Button\n  </Button>\n  <Button\n    color='primary'\n    margin=\"0 0 0 small\"\n    themeOverride={(_componentTheme, currentTheme) => ({\n      primaryBackground: currentTheme.colors.backgroundWarning,\n      primaryBorderColor: currentTheme.colors.backgroundLightest,\n      borderWidth: currentTheme.borders.widthLarge,\n      borderStyle: 'dashed'\n    })}\n  >\n    Button\n  </Button>\n</div>\n```\n\n#### InstUISettingsProvider\n\n`InstUISettingsProvider` is a React component, which wraps Emotion's own `ThemeProvider`.\n\nIt accepts a `theme` prop, which should be an Instructure UI theme.\n\nIt can be used in two ways. On the top level, you can provide the theme for the whole application or nested anywhere inside it. You can also provide an object with theme or component theme overrides.\n\n**For detailed usage info and examples, see the [InstUISettingsProvider](#InstUISettingsProvider) documentation page.**\n\n```jsx\n---\ntype: code\n---\nimport Button from './Button'\nimport { InstUISettingsProvider } from '@instructure/emotion'\nimport { canvasHighContrast } from '@instructure/ui-themes'\n\nconst RenderApp = () => {\n  return (\n    <InstUISettingsProvider theme={canvasHighContrast}>\n      <Button />\n    </InstUISettingsProvider>\n  )\n}\n```\n\n### Defining variables\n\nThe themeable component uses the JS variables defined in the `theme.js` file.\n\nFor example, to add a variable for the hover state of a Button component, the `theme.js` file might contain the following:\n\n```js\n---\ntype: code\n---\n// Button/theme.js\nconst generateComponentTheme = (theme) => {\n  const { colors } = theme\n\n  const componentVariables = {\n    background: colors?.blue4570,\n    color: colors?.white1010,\n\n    hoverColor: colors?.blue5782,\n    hoverBackground: colors?.blue1212\n  }\n\n  return componentVariables\n}\nexport default generateComponentTheme\n```\n\nThe arguments to the generator function are the [global theme variables](#canvas). In the above example, we've defined the default theme for the Button component.\n\nThe purpose of the generator function is to take the global variables and apply them as values to the functional component level variables.\nWhen coming up with names for the component level variables, try to make them describe how they are used in the component (vs describing the variable value).\n\n### Supporting multiple themes\n\nIf we want to make the Button transform the global theme variables differently with another theme, (e.g. [canvas-high-contrast](#canvas-high-contrast)) we can make specific styling for that theme:\n\n```js\n---\ntype: code\n---\n// Button/theme.js\nconst generateComponentTheme = (theme) => {\n  const { colors, key: themeName } = theme\n\n  const themeSpecificStyle = {\n    'canvas-high-contrast': {\n      background: colors.white1010\n    }\n  }\n\n  const componentVariables = {\n    background: colors?.blue5782,\n    color: colors?.blue5782,\n\n    hoverColor: colors?.blue4570,\n    hoverBackground: colors?.grey125125\n  }\n\n  return {\n    ...componentVariables,\n    ...themeSpecificStyle[themeName]\n  }\n}\nexport default generateComponentTheme\n```\n\nThis will override the default Button theme and use the global theme variable `colors.blue5782` for the value of its `background` theme variable instead of `colors.white1010`.\n\nThe rest of the variables will pick up from the default Button theme generator (applying the global theme variables from the `canvas-high-contrast` theme).\n\n### Using theme variables in styles.js\n\nIn the `styles.js` file, the `generateStyle` method receives the theme variable object (`componentTheme`) generated by `theme.js`.\n\nAdd your styling for each element in the component, and give them [labels](https://emotion.sh/docs/labels#gatsby-focus-wrapper) for easy readability and targetability. _Naming convention_: similar to [BEM naming convention](#http://getbem.com/naming/), use the name of the component in camelCase for the root element ('button'), and the double underscore suffix for children ('button\\_\\_icon').\n\nUse [Emotion's Object Styles documentation](https://emotion.sh/docs/object-styles) as a guide to add styles.\n\nNote: Don't worry about scoping your CSS variables (the [emotion](#emotion) library will take care of that for you):\n\n```js\n---\ntype: code\n---\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  return {\n    button: {\n      label: 'button',\n      background: componentTheme.background,\n      color: componentTheme.color,\n\n      '&:hover': {\n        background: componentTheme.hoverBackground,\n        color: componentTheme.hoverColor\n      }\n    },\n    icon: {\n      label: 'button__icon',\n      display: 'inline-block',\n      fill: 'currentColor'\n    }\n  }\n}\nexport default generateStyle\n```\n\nThe `generateStyle` method also automatically receives all the props of the component, so you can add styling based on them:\n\n```js\n---\ntype: code\n---\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  const { display, isDisabled } = props\n\n  const displayVariants = {\n    inline: {\n      display: 'inline-block'\n    },\n    block: {\n      display: 'block',\n      margin: 0\n    },\n    none: {\n      display: 'none'\n    }\n  }\n\n  return {\n    button: {\n      label: 'button',\n      // ...\n      ...(isDisabled && { opacity: 0.5 }),\n      ...displayVariants[display]\n    }\n    // ...\n  }\n}\nexport default generateStyle\n```\n\nYou can also pass additional variables from the component via the `makeStyles` prop. These can be values from the state or from getters, etc.\n\nNote: don't forget to pass them both in `componentDidMount` and `componentDidUpdate` methods!\n\n```js\n---\ntype: code\n---\n// Button/index.js\nclass Button extends React.Component {\n  static propTypes = {\n    // eslint-disable-next-line react/require-default-props\n    makeStyles: PropTypes.func,\n    // eslint-disable-next-line react/require-default-props\n    styles: PropTypes.object\n  }\n\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      focused: false\n    }\n  }\n\n  componentDidMount() {\n    this.props.makeStyles({\n      focused: this.state.focused,\n      someValue: this.someValue\n    })\n  }\n\n  componentDidUpdate() {\n    this.props.makeStyles({\n      focused: this.state.focused,\n      someValue: this.someValue\n    })\n  }\n\n  get someValue() {\n    return 'some value here'\n  }\n\n  render() {\n    // ...\n  }\n}\n\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  const { focused, someValue } = state\n\n  return {\n    button: {\n      label: 'button',\n      // ...\n      ...(someValue === 'not that value' && { display: 'none' }),\n      ...(focused && {\n        borderWidth: '2px',\n        ...(someValue === 'not that value' && { display: 'block' })\n      })\n    }\n    // ...\n  }\n}\nexport default generateStyle\n```\n\n### Using theme variables in JavaScript\n\nSince the variables are defined in JS you can easily pass them through `styles.js` to access in your component JS.\n\n```js\n---\ntype: code\n---\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  return {\n    button: {\n      label: 'button'\n      // ...\n    },\n    maxWidth: componentTheme.maxWidth\n  }\n}\n\n// Button/index.js\nrender() {\n  const { propVal1, styles, ...props } = this.props\n\n  return (\n    <div maxWidth={styles.maxWidth}>\n      ...\n    </div>\n  )\n}\n```\n\n#### Global styles\n\nWrite your global styles in the `styles.js` file on a \"globalStyles\" key. You don't have to add labels to global styles.\n\n```js\n---\ntype: code\n---\n// styles.js\n\nreturn {\n  globalStyles: {\n    '.CodeMirror': {\n      height: 'auto',\n      background: componentTheme.background\n      // ...\n    }\n  }\n}\n```\n\nIn the `index.js`, import `Global` from `@instructure/emotion`, which is equivalent to the [Global](https://emotion.sh/docs/globals) component of Emotion.js.\n\nIn the render method, use the `<Global>` component and pass the the \"globalStyles\" as its `styles={}` property.\n\n```jsx\n---\ntype: code\n---\n// index.js\n\nimport { withStyle, jsx, Global } from '@instructure/emotion'\n\n// ...\n\nrender() {\n  const { styles } = this.props\n\n  return (\n    <div css={styles.codeEditor}>\n      <Global styles={styles.globalStyles} />\n      // ...\n    </div>\n  )\n}\n```\n\n#### Keyframes\n\nAnimations are handled with Emotion's [keyframes](https://emotion.sh/docs/keyframes) helper.\n\nImport `keyframes` from `@instructure/emotion` in the `styles.js` file.\n\nDefine the animation on the top of the page as a `const` and use it in your style object where needed. **Make sure that it is defined outside of the `generateStyle` method, otherwise it is causing problems with style recalculation.**\n\n```js\n---\ntype: code\n---\n// styles.js\n\nimport { keyframes } from '@instructure/emotion'\n\nconst pulseAnimation = keyframes`\n  to {\n    transform: scale(1);\n    opacity: 0.9;\n  }`\n\nconst generateStyle = (componentTheme, props, state) => {\n  // ...\n\n  return {\n    componentClass: {\n      // ...\n      animationName: pulseAnimation\n    }\n  }\n}\n```\n\n#### Writing theme tests\n\nFor components with theme tests, you can use `generateComponentTheme` from `theme.js` to get the theme variables.\n\nImport the themes needed for your test, and pass them to the generator.\n\n```js\n---\ntype: code\n---\nimport { canvas, canvasHighContrast } from '@instructure/ui-themes'\nimport generateComponentTheme from '../theme'\n\ndescribe('YourComponent.theme', () => {\n  describe('with canvas theme', () => {\n    const variables = generateComponentTheme(canvas)\n\n    describe('default', () => {\n      it('should ensure background color and text color meet 3:1 contrast', () => {\n        expect(contrast(variables.background, variables.color)).to.be.above(3)\n      })\n    })\n  })\n  describe('with the \"canvas-high-contrast\" theme', () => {\n    const variables = generateComponentTheme(canvasHighContrast)\n\n    describe('default', () => {\n      it('should ensure background color and text color meet 4.5:1 contrast', () => {\n        expect(contrast(variables.background, variables.color)).to.be.above(4.5)\n      })\n    })\n  })\n})\n```\n\n[![npm][npm]][npm-url]\n\n[![MIT License][license-badge]][license]\n\n[![Code of Conduct][coc-badge]][coc]\n\nA UI component library made by Instructure Inc.\n\n### Installation\n\n```sh\n\nnpm install @instructure/emotion\n\n```\n\n[npm]: https://img.shields.io/npm/v/@instructure/emotion.svg\n[npm-url]: https://npmjs.com/package/@instructure/emotion\n[license-badge]: https://img.shields.io/npm/l/instructure-ui.svg?style=flat-square\n[license]: https://github.com/instructure/instructure-ui/blob/master/LICENSE.md\n[coc-badge]: https://img.shields.io/badge/code%20of-conduct-ff69b4.svg?style=flat-square\n[coc]: https://github.com/instructure/instructure-ui/blob/master/CODE_OF_CONDUCT.md\n","category":"packages","relativePath":"packages/emotion/README.md","extension":".md","srcPath":"packages/emotion/README.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/emotion/README.md","packageName":"@instructure/emotion","requirePath":"@instructure/emotion/README","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/emotion/README.md').default","esPath":"@instructure/emotion/README","themePath":"packages/emotion/README.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/emotion/README.md","id":"emotion","title":"emotion"}