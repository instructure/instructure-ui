---
title: Testing library
category: Testing
order: 2
---

## About the `ui-test-utils`

`@instructure/ui-test-utils` is a UI testing library created by Instructure's UI Development team. It provides developers with a framework for writing reliable, performant tests on the DOM:

- Built-in implicit waits for DOM queries and utils to retry assertions
- Helpers for common DOM assertions
- Built-in test suite setup/teardown to prevent test case pollution
- Stub/spy helpers to test callback props
- A utility to generate a11y tests
- A utility to make it easy to create UI component Page Object Models

`ui-test-utils` wraps popular third-party testing libraries that can be swapped out as needed without replacing and rewriting everything.

### Quick start

#### Tech stack

`ui-test-utils` is built to work with the [Mocha JavaScript testing framework](https://mochajs.org) and uses the [Chai assertion library](https://www.chaijs.com). If you would like to run your tests in the Chrome browser, `ui-test-utils` can be used with Webpack and the [Karma test runner](https://karma-runner.github.io).

We don't recommend or officially support running tests using [jsdom](https://github.com/jsdom/jsdom). While you might be able to use `ui-test-utils` with [Jest](https://jestjs.io/) and jsdom, jsdom will likely require polyfills for native browser APIs that we use in our components.

#### Installation

To set up your environment to use `@instructure/ui-test-utils`, install the following:

- To install a CLI, `ui-test` globally that you can use to run your tests:
  `npm install -g @instructure/ui-scripts`
- To install the utils, the karma test runner and webpack:
  `npm install --save-dev @instructure/ui-test-utils @instructure/ui-karma-config webpack`

#### Configuration

Create a `karma.conf.js` file in your project root

```javascript
// karma.conf.js
const path = require('path')

module.exports = require('@instructure/ui-karma-config')({
  coverageThreshold: {
    global: {
      statements: 87,
      branches: 70,
      functions: 80,
      lines: 87
    }
  },
  coverageDirectory: path.join(__dirname, '/coverage')
})
```

#### Running tests

Run the `ui-test` script to run all tests in your project in headless Chrome.

> The test files should be placed inside `packages/` directory, supported extensions : .test.tsx, .test.ts, .test.js

If you’d like to debug a test, you can run `ui-test --watch` to run the tests in Chrome and watch for changes to your source.

To use the Chrome dev tools while your tests are running, find the Chrome browser that opens up when you run `ui-test --watch`, and then click on the “Debug” button and open Chrome dev tools.

## Testing philosophy

### What we want

- **We want to test the semantic DOM**. Why? Because the DOM reflects what’s actually happening for the user.
- **We have a need for speed**. We favor tests written at the smallest possible testable component level. They run faster and provide better feedback during development.
- **We want robust tests**. Sure, we want a speedy test suite, `ui-test-utils` favors an “everything is async” approach, providing built-in waits and retries for DOM assertions and queries.

### What we don’t want

- **We don’t want to test UI implementation details**. Avoid asserting on CSS classes, non-semantic DOM elements, private child props, or component state. Tests that assert on implementation details are likely to break, even when there is no user-facing change. This is a blocker to being able to automate dependency upgrades and makes taking on technical debt/refactoring more costly.
- **We don’t want flaky/brittle tests**. Async DOM updates like transitions or API calls can cause tests to fail inconsistently. Therefore, we favor “always waiting for everything”: Every DOM interaction should wait for a DOM assertion following it.
- **We don’t want sloooow tests**. Long build times are usually the result of too many integration or end-to-end tests. We favor writing tests at the smallest possible component level.

## Writing testable components

### Write props-driven, controlled, stateless components

Keep components that render markup and styles separate from business logic, state management code, API calls, and ideally even React context...

- ...so that tests can be generated by configuring props/value combinations only
- ...so that there is very little setup and mocking required to render and test the component in isolation

### Build and test components in isolation

Avoid global CSS styles/resets and the CSS cascade...

- ...using a sandbox setup like [storybook](https://storybook.js.org/)
- ...for faster feedback during development and to identify points of failure more easily

### Clean up on unmount

Clean up on unmount to prevent test case pollution. Always cancel/remove these:

- `requestAnimationFrame`
- `setTimeout`
- Native event listeners
- `XMLHttpRequest`
- Injected DOM nodes when the UI component unmounts

## Writing tests

See [Writing tests](/#writing-tests) for details.

## Test cookbook

### Writing robust CSS selectors

**Avoid using class names in your selectors**. They’re considered an implementation detail and may change multiple times over the course of a component’s life. It should also be noted that while `ui-test-utils` permits class name selectors, they may be disallowed in the future -- and who really wants to go back and redo tests?

In addition, please **avoid selecting `div` or `span` elements**. These elements have no semantic value and are simply styling hooks. If you try to select them, `ui-test-utils` will throw a console error.

So what _should_ you use in your selectors? Well, the first thing to note is that if you have a choice between selecting an element via CSS or the text it contains, we recommend going with the text: Basing your queries on text content will make them easier to debug in the test output, and it is unlikely you will have to update your tests when the component is refactored.

However, if you need to use CSS selectors, we recommend targeting the **semantic parts of the rendered DOM**:

- **Semantic element names**. A `<header>`, for example, describes a specific type of content and is a tag that is unlikely to change over the course of the component’s life.

```javascript
const header = await myComponent.find('header')
```

- **Accessibility attributes**. Attributes like `role`, `type`, or `alt` make great selector targets because they describe what the element does and are also unlikely to change with, say, a design update to the component. ARIA attributes are also great to use in selectors.

```javascript
const dialog = myComponent.find('[role="dialog"]')

const dialog = myComponent.find('[aria-label="Dialog"]')
```
