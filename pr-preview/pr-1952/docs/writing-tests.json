{"description":"\n> This section uses [`@instructure/ui-test-utils`](/#ui-test-utils) testing library which will be sunset in our next\n> release in favor of Vitest + React Testing Library. See [our guide](/#converting-old-tests) on how to convert legacy tests to use the new\n> frameworks.\n\n## The anatomy of a test\n\nThe following code example presents an annotated version of a typical test. The terms in the comments will be explained over the course of this section.\n\n```js\n---\ntype: code\n---\nimport React from 'react'\nimport {\n  mount,\n  stub,\n  wait,\n  expect,\n  findWithLabel,\n  findWithText\n} from '@instructure/ui-test-utils'\n\nimport MyComponent from '../index'\nimport { setupFixtures, cleanupFixtures } from './fixtures'\n\n// test suite:\ndescribe('<MyComponent/>', async () => {\n  // async/await\n  // hook:\n  beforeEach(async () => {\n    await setupFixtures()\n  })\n\n  // hook:\n  afterEach(async () => {\n    await cleanupFixtures()\n  })\n\n  // test case:\n  it('should do something', async () => {\n    // stub:\n    const handleClick = stub()\n\n    // mounting a component:\n    await mount(\n      <MyComponent buttonLabel=\"My button label\" onClick={handleClick} />\n    )\n\n    // query:\n    const button = await findWithLabel('My button label')\n\n    // query result with event helper:\n    await button.click()\n\n    // assertion with wait:\n    await wait(() => {\n      expect(handleClick).to.have.been.calledOnce()\n    })\n\n    // query:\n    const response = await findWithText(\n      'My response text',\n      // query options:\n      { exact: false }\n    )\n\n    // assertion:\n    expect(response).to.exist()\n  })\n})\n```\n\n### Test suites and test cases\n\n#### Test suites: `describe()`\n\nTest suites are how the Mocha framework groups tests. Create a suite by using a `describe()` function that returns all the tests included in the suite:\n\n```js\n---\ntype: code\n---\ndescribe('when variant is set to rectangle', async () => {\n  // all the tests related to the rectangle variant\n})\n```\n\nYou can nest your tests in groups as deep as you deem necessary. The main benefit to thoughtful nesting is that your tests (especially those for complex components) will stay organized and be easier for other developers to maintain. In addition, grouping tests by category will make the console output from your tests will be easier to parse. Finally, by using `describe.only(‘...’)`, you can limit your tests to only run on a certain suite and test hooks ([see below](/#writing-tests/#the-anatomy-of-a-test-hooks-and-the-test-sandbox)) are scoped to all tests within the `describe` block where they are defined.\n\n#### Test cases: `it()`\n\nIn Mocha, each test case (or each individual test) goes inside an `async it()` function. To keep your tests consistent and make your test output a pleasure to read, we recommend sticking to an `it('should [do something]')` format when writing test cases.\n\n### Async and await\n\n#### UI tests should be asynchronous.\n\nFor readers without JavaScript backgrounds, this is a fancy way of saying that when you’re testing the DOM, you want to wait for something to happen before you move on to the next thing. Why? Because on the web, stuff happens all the time that makes tests that don’t wait (a.k.a., synchronous tests) brittle and unreliable -- stuff like the time it takes for animations to complete, or the time it takes to make an API call: You never know exactly how long that stuff will take, so the safest strategy is to make sure it’s done before you move on.\n\nSo when you see the following query, what is going on under the hood?\n\n```js\n---\ntype: code\n---\nconst input = await container.find('input')\n```\n\nThe `await` operator is waiting for a [JavaScript Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) to be fulfilled. In this case, the Promise will be fulfilled if an `<input />` can be found inside the container. `ui-test-utils` will make an initial attempt to locate the element. If the `<input />` is found right away, great: The test moves on to the next line.\n\nHowever, if the `<input />` is not found, `ui-test-utils` waits for any DOM change for the duration of our default timeout of 2s. (This duration can be overridden by passing in a `timeout` option to the `find` method.) If a DOM change is detected, the test looks for the input again. If no DOM change occurs, however, the test will fail when it reaches the end of the timeout.\n\nBecause we’re using the Javascript keyword `await` in our test, we need to let the test runner know that this test is asynchronous, so we mark the test function with the keyword `async`. See the [Mocha documentation on asynchronous tests](https://mochajs.org/#using-async-await) for more details.\n\n### Hooks and the test sandbox\n\nRemember at nursery school when you’d sing that “clean up, clean up” song while you put your toys away? Well, that’s a big part of what hooks do. They’re handy functions built into [Mocha](https://mochajs.org/#hooks) that you can use to set up or clean up after your tests.\n\n```js\n---\ntype: code\n---\nbeforeEach(async () => {\n  // don’t forget your async/await here too!\n  await doSomethingAsync()\n})\n```\n\n> Not that you shouldn’t read this section carefully, but one of the advantages of using `ui-test-utils` is that **its built-in test sandbox will handle the majority of test cleanup for you**. As a result, you probably won’t need to use hooks very often.\n\nWhen you use `ui-test-utils`, a global `beforeEach` and `afterEach` hook is automatically set up for you to help ensure that your tests clean up after themselves. If you use the `stub` and `spy` utilities provided by `ui-test-utils`, they will be reset automatically between tests (via [sinon’s sandbox](https://sinonjs.org/releases/latest/sandbox/)). The `ui-test-utils` sandbox also ensures that any DOM changes made during a test run are cleaned up automatically.\n\n### Spies and stubs\n\nA stub is a function with pre-programmed behavior. Stubs can be used to test DOM interactions with a UI component via the component’s callback props. For more information, see https://sinonjs.org/releases/latest/stubs.\n\nA spy is a function that records arguments and returns values, etc. for any calls. Like stubs, spies can be used to test DOM interactions with a UI component via its callback props. For more information, see https://sinonjs.org/releases/latest/spies.\n\n> Note that when you use stubs and spies in `ui-test-utils`, the built-in test sandbox will handle the clean-up for you. Yay!\n\n### Mounting your component\n\nTo assert on a component, you must first get it mounted -- meaning rendered into the document.\n\n```js\n---\ntype: code\n---\nimport { mount, find } from '@instructure/ui-test-utils'\nimport MyComponent from '../index'\n\nit('should mount', async () => {\n  await mount(<MyComponent buttonLabel=\"my button label\" />)\n\n  const button = await findWithLabel('my button label')\n  expect(button).to.exist()\n})\n```\n\n### Queries\n\nTo prove that something is happening in a component, you need to find stuff within that component, so you can see what’s going on in its rendered DOM. This is where queries come in: They allow you to dive into the component’s DOM and return results you can make assertions against.\n\n> We recommend using `findWithLabel` and `findWithText` whenever possible. Basing your queries on text content (as opposed to an HTML element) will make them easier to debug and you shouldn’t have to update your tests when the component is refactored.\n\n| Query         | Description                                                                                                     | Example                               |\n| ------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------- |\n| find          | Finds a single element that matches a CSS selector                                                              | `await find(\"[role='menu']\")`         |\n| findAll       | Finds all elements that match a CSS selector                                                                    | `await findAll('button')`             |\n| findWithText  | Finds an element that contains text content that matches the argument                                           | `await findWithText('Collection 2')`  |\n| findWithTitle | Finds an element that has a title (element, for SVG, or attribute for other elements) that matches the argument | `await findWithTitle('Collection 2')` |\n| findWithLabel | Finds an element that is labeled by text that matches the argument                                              | `await findWithLabel('Item1')`        |\n\n#### Query Arguments\n\nThe query functions above accept three arguments: an HTML element, a CSS selector or text, and an options object.\n\nIf you pass in an HTML element, the query will search within (and including) that element for matches. By default, the query will search the entire HTML document.\n\n#### Query Selectors\n\nYou can pass any built-in CSS selector to a query:\n\n```js\n---\ntype: code\n---\nconst allSVGs = await subject.findAll('svg')\nconst visibleFrame = await subject.find('iframe:not([title=\"always-hidden\"])')\n```\n\n> OK, any CSS selector EXCEPT one that includes `div` or `span`. Querying these elements will cause an error because they don’t have semantic value, and their use therefore falls under the category of an implementation detail.\n\nIn addition to valid native [CSS selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), `ui-test-utils` uses the [Sizzle CSS selector engine](https://sizzlejs.com) to make the following custom selectors available for use in tests:\n\n| Selector  | Description                                       | Example                       |\n| --------- | ------------------------------------------------- | ----------------------------- |\n| visible   | Filters queries to elements that are visible      | `await findAll(':visible')`   |\n| tabbable  | Filters queries to elements that can be tabbed to | `await findAll(':tabbable')`  |\n| focusable | Filters queries to elements that can be focused   | `await findAll(':focusable')` |\n| clickable | Filters queries to elements that can be clicked   | `await findAll(':clickable')` |\n\n#### Query Options\n\nYou can pass the following options to your query:\n\n| Option             | Default          | Description                                                                                                   |\n| ------------------ | ---------------- | ------------------------------------------------------------------------------------------------------------- |\n| collapseWhitespace | `true`           | Whether newlines, tabs and multiple spaces should be collapsed into a single space before attempting to match |\n| customMethods      |                  | custom methods to apply to the query results                                                                  |\n| exact              | `true`           | Whether a text match can be a partial and non-case-sensitive or exact                                         |\n| expectEmpty        | false            | Whether you expect any results or not                                                                         |\n| ignore             | `'script,style'` | elements to ignore                                                                                            |\n| timeout            | `1900`           | how long to wait/retry                                                                                        |\n| trim               | `true`           | whether text should be trimmed of whitespace before attempting to match                                       |\n\n#### Querying for an element that should not be there\n\nThe query option you will most frequently use will be `expectEmpty`. When you need to make a negative assertion, set `expectEmpty` to `true`, so that the query function knows that the desired result of the query is for nothing to be found. Otherwise, your test will time out and fail.\n\n```js\n---\ntype: code\n---\nconst foo = await FooLocator.find({ expectEmpty: true })\n```\n\nAs a general rule, it’s best to avoid negative assertions (asserting that something should not exist or happen): In UI code, things often happen asynchronously, and the element might appear or the behavior might happen after you’ve made your assertion -- meaning your test could pass when it really shouldn’t.\n\n#### Query Results\n\nThe above query methods are applied to query results, so that it’s easy to run additional queries within them.\n\n```js\n---\ntype: code\n---\nconst form = await find('form')\n\n// call helper methods on the results of a find query\nconst formNode = form.node()\n\n// query methods are attached to the results\n// call them to query within the result’s DOM node\nconst inputs = await form.findAll('input')\n\n// call helper methods on each result of a findAll query\nconst inputNodes = inputs.map((input) => input.node())\n```\n\n#### Helpers\n\nIn addition to the query methods, query results have the following helpers applied to them:\n\n| Helper function                 | Description                                                                                        |\n| ------------------------------- | -------------------------------------------------------------------------------------------------- |\n| `ancestors([selector])`         | Returns all of the ancestor nodes that match [selector]                                            |\n| `attribute([attribute])`        | Returns the attribute value of the node                                                            |\n| `bounds([property])`            | Returns the value of the bounding rect property (e.g. 'left')                                      |\n| `checked()`                     | Returns true if the node is checked                                                                |\n| `classNames()`                  | Returns the class list of the node as an array                                                     |\n| `clickable()`                   | Returns true if the element is visible and clickable (pointer events aren’t disabled)              |\n| `contains([selector\\|element])` | Returns true if the node contains an element that matches [selector] or if it contains [element]   |\n| `containsFocus()`               | Returns true if the node contains or is the active element                                         |\n| `debug()`                       | Logs the HTML markup of the result to the console                                                  |\n| `descendants([selector])`       | Returns all of the descendant nodes that match [selector]                                          |\n| `disabled()`                    | Returns true if the node is disabled                                                               |\n| `empty()`                       | Returns true if the node has no children (including text nodes)                                    |\n| `exists()`                      | Returns true if the node is rendered in the document                                               |\n| `focusable()`                   | Returns true if the element is focusable                                                           |\n| `focused()`                     | Returns true if the node is the active element (focused)                                           |\n| `hasClass([className])`         | Returns true if the node has [className] in its class list                                         |\n| `id()`                          | Returns the id of the node                                                                         |\n| `label()`                       | Returns the accessible label of the element                                                        |\n| `matches([selector])`           | Returns true if the node matches the [selector] string                                             |\n| `node()`                        | Returns the DOM node found by the query                                                            |\n| `parent()`                      | Returns the parent DOM node                                                                        |\n| `readonly()`                    | Returns true if the node is readonly                                                               |\n| `rect()`                        | Returns the bounding client rect of the node                                                       |\n| `role()`                        | Returns the role of the node                                                                       |\n| `selected()`                    | Returns true if the node is selected                                                               |\n| `style([property])`             | Returns the computed style property of the node                                                    |\n| `tabbable()`                    | Returns true if the element is focusable and has a non-negative tab index                          |\n| `tagName()`                     | Returns the tagName of the node                                                                    |\n| `text()`                        | Returns the text content of the node                                                               |\n| `title()`                       | Returns the title (attribute or element, if SVG)                                                   |\n| `toString()`                    | Returns the HTML markup of the result as a string                                                  |\n| `typeIn([string])`              | Simulates typing [string] into the node (assumes that it is an input, textarea or contenteditable) |\n| `value()`                       | Returns the value of the node                                                                      |\n| `visible()`                     | Returns true if the element is visible on screen                                                   |\n\n### Events\n\nA DOM interaction, or event, is fired either due to real user interaction with a browser, or programmatically via a UI test.\n\nNote that React uses [synthetic events](https://reactjs.org/docs/events.html). However, we recommend testing by firing and verifying native DOM events when possible (the fact that we're using React events is an implementation detail).\n\n`ui-test-utils` provides access to all native [web events](https://developer.mozilla.org/en-US/docs/Web/Events) as helper methods on query results.\n\n```js\n---\ntype: code\n---\nconst component = await ComponentLocator.find()\nawait component.mouseDown()\n```\n\nFor keyboard events (`keyDown`, `keyPress`, `keyUp`), `ui-test-utils` uses the [keycodes library](https://github.com/timoxley/keycode) to make it easy to specify which key (as the first argument), using a string label.\n\n```js\n---\ntype: code\n---\nawait component.keyDown('enter')\n```\n\nThe second argument for keyboard events, and the first for all others, is an optional `Event` initialization object that is passed into the native `Event` constructor.\n\n```js\n---\ntype: code\n---\nawait component.click({ button: 0, bubbles: false })\n```\n\n### Assertions\n\nIf you’ve ever accused Professor Plum of murder in the library with the lead pipe while playing Clue, you’ve made an assertion. The assertion is the grand conclusion of your test, where you state what you think will happen based on the results of your query.\n\n`ui-test-utils` uses chai’s `expect()` assertion style (https://www.chaijs.com) to make assertions on components. In addition, the following custom assertions are available to make assertions on a query result:\n\n- `expect(await find([selector]))`\n- `.to.have.tagName([tagName])`\n- `.to.have.id([id])`\n- `.to.have.style([property], [value])`\n- `.to.have.attribute([attribute], [value]).to.have.label([label])`\n- `.to.have.title([title])`\n- `.to.have.value([value])`\n- `.to.exist()`\n- `.to.have.className([className])`\n- `.to.be.disabled()`\n- `.to.be.readonly()`\n- `.to.have.role([role])`\n- `.to.be.selected()`\n- `.to.be.checked()`\n- `.to.match([selector])`\n- `.to.be.focused()`\n- `.to.have.focus()`\n- `.to.be.focusable()`\n- `.to.be.tabbable()`\n- `.to.be.visible()`\n- `.to.be.clickable()`\n- `.to.have.text([text])`\n- `.to.have.bounds([property], [value])`\n- `.to.have.exactly([count]).descendants([selector])`\n- `.to.have.exactly([count]).ancestors([selector])`\n- `.to.contain([selector|element])`\n- `.to.be.empty()`\n\n### Testing for accessibility\n\nOnce you've mounted your component in the document you can run tools like [axe-core](https://www.deque.com/axe/) to verify that the rendered markup meets accessibility requirements. `ui-test-utils` provides a wrapper utility for running `axe-core`:\n\n```js\n---\ntype: code\n---\nimport { accessible, mount, expect } from '@instructure/ui-test-utils'\n\nit('should be accessible', async () => {\n  await mount(<MyComponent />)\n  expect(await accessible()).to.be.true()\n})\n```\n\n### Testing responsive components\n\nTesting the behavior of responsive components often requires changing the browser viewport size. `ui-test-utils` provides a utility to do just that:\n\n```js\n---\ntype: code\n---\nimport { viewport, stub } from '@instructure/ui-test-utils'\n\nit('should do something when the viewport size changes', async () => {\n  const handleResize = stub()\n  await mount(<MyComponent onResize={handleResize} />)\n\n  // sets the viewport to 320px x 480px\n  viewport.set(320, 480)\n\n  expect(handleResize).to.have.been.calledOnce()\n})\n```\n\nThe test sandbox is configured to call `viewport.reset()` in between each test, so you don’t have to worry about resetting the viewport size.\n\n### Locators: page object models for components\n\n**A locator is a collection of query methods and CSS selectors that makes your tests easier to maintain.**\n\nIf you’re familiar with the concept of [Page Object Models](https://martinfowler.com/bliki/PageObject.html), it might be helpful to think of locators as POMs for UI components. Locators ideally live with their components, making it easy to keep them up-to-date when the component implementation is updated.\n\nThe only required argument in a locator is a _semantic_ (don’t use classes, divs, or spans) CSS selector:\n\n```js\n---\ntype: code\n---\nimport { locator } from '@instructure/ui-test-utils'\nexport const fooLocator = locator('[data-foo]')\n```\n\nImport this basic locator into your tests file, and you can now use it as follows:\n\n```js\n---\ntype: code\n---\nconst foo = await fooLocator.find()\n```\n\n`foo` will now give you the first matching element with a `data-foo` attribute.\n\n> **When should you make a locator?**\n>\n> Make a locator for any component that has something inside it you need to repeatedly interact with in your tests. Locators should not be added for components that are presentational (grid or flex layout components, for example). Because these components are comprised of styled `<div>` or `<span>` elements with no semantic value, they (and their CSS classes) can be considered implementation details.\n\nLocators are more than just selector shortcuts: They can take an object of custom methods (functions you can run on the results) as their second argument. Here’s a shortened example from Instructure UI’s `ToggleDetails` component:\n\n```js\n---\ntype: code\n---\nimport { locator } from '@instructure/ui-test-utils'\nimport ToggleDetails from './index'\n\nconst ToggleLocator = locator('[aria-expanded][aria-controls]')\n\nexport const customMethods = {\n  clickToggle: async (element, ...args) =>\n    (await ToggleLocator.find(element)).click(...args)\n}\n\nexport default locator(ToggleDetails.selector, customMethods)\n```\n\nThis locator first defines the CSS selector it will use to find the element that does the toggling in `ToggleDetails`. Then it defines a custom method that test writers can use to click this element. The `ToggleDetails.selector` in the export is a `ui-test-utils` feature that will add a data attribute to the root element in the `ToggleDetails` component that the library uses as a hook when the test writer uses the locator:\n\n```js\n---\ntype: code\n---\nimport ToggleDetailsLocator from '../locator'\nconst toggleDetails = await ToggleDetailsLocator.find()\n```\n","title":"Writing tests (legacy)","category":"Testing","order":3,"relativePath":"docs/testing/writing-tests.md","extension":".md","srcPath":"docs/testing/writing-tests.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/docs/testing/writing-tests.md","packageName":"@instructure/docs","requirePath":"@instructure/docs/testing/writing-tests","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/docs/testing/writing-tests.md').default","esPath":"@instructure/docs/testing/writing-tests","themePath":"docs/testing/writing-tests.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/docs/testing/writing-tests.md","id":"writing-tests"}