{"description":"\n`Options` is a view-only component for creating option lists and menus, like those used in [Select](Select) and [Menu](Menu). It should only be used if an existing component doesn't offer the level of customization needed.\n\nThe `variant` prop of `Option.Item` provides several visual treatments. Use the `highlighted` variant to indicate that an option is being hovered, focused, or otherwise interacted with and the `selected` variant to indicate the selected option.\n\n```js\n---\ntype: example\n---\n<View display=\"block\" width=\"300px\">\n  <Options>\n    <Options.Item onClick={() => console.log('clicked!')}>\n      Default option\n    </Options.Item>\n    <Options.Item variant=\"highlighted\">\n      Highlighted option\n    </Options.Item>\n    <Options.Item variant=\"selected\">\n      Selected option\n    </Options.Item>\n    <Options.Item variant=\"disabled\">\n      Disabled option\n    </Options.Item>\n    <Options.Item variant=\"highlighted-disabled\">\n      Highlighted disabled option\n    </Options.Item>\n  </Options>\n</View>\n```\n\n`Options` components can be nested to create sub menus. Icons may be added to any `Options.Item` before or after its text content using `renderBeforeLabel` and `renderAfterLabel` respectively.\n\n> `Options` and `Options.Item` receive default roles of `list` and `listitem` respectively, but the most applicable roles should be used. These will commonly be `listbox`/`option` or `menu`/`menuitem`.\n\n```js\n---\ntype: example\n---\n<View display=\"block\" width=\"300px\">\n  <Options role=\"menu\" as=\"ul\">\n    <Options.Item role=\"menuitem\">\n      Option one\n    </Options.Item>\n    <Options.Item role=\"menuitem\" variant=\"highlighted\">\n      Option two\n    </Options.Item>\n    <Options.Item role=\"menuitem\" renderAfterLabel={IconArrowOpenEndSolid}>\n      Flyout menu option\n    </Options.Item>\n    <Options.Separator as=\"li\" />\n    <Options role=\"menu\" as=\"ul\" renderLabel={'Sub menu'}>\n      <Options.Item role=\"menuitem\">\n        Sub option one\n      </Options.Item>\n      <Options.Item role=\"menuitem\">\n        Sub option two\n      </Options.Item>\n    </Options>\n    <Options.Separator />\n    <Options role=\"menu\" as=\"ul\" renderLabel={'Radio group'}>\n      <Options.Item\n        role=\"menuitemradio\"\n        aria-checked=\"true\"\n        renderBeforeLabel={IconCheckSolid}\n      >\n        Radio option one\n      </Options.Item>\n      <Options.Item\n        role=\"menuitemradio\"\n        aria-checked=\"false\"\n        renderBeforeLabel={\n          <IconCheckLine style={{opacity: 0}} />\n        }\n      >\n        Radio option two\n      </Options.Item>\n    </Options>\n    <Options.Separator />\n    <Options.Item role=\"menuitem\">\n      Option three\n    </Options.Item>\n  </Options>\n</View>\n```\n\n`Options` does not manage any state or react to any user interaction. The consuming component or app should listen for events on items and update the `variant` props accordingly via its own state.\n\n```js\n---\ntype: example\n---\nconst Example = ({ options }) => {\n  const [highlighted, setHighlighted] = useState(-1)\n  const [selected, setSelected] = useState(-1)\n\n  const handleKeyDown = (event) => {\n    let index = highlighted\n\n    if (event.keyCode === 40 && highlighted < options.length - 1) {\n      // down arrow\n      event.preventDefault()\n      index = highlighted + 1\n    } else if (event.keyCode === 38 && highlighted > 0) {\n      // up arrow\n      event.preventDefault()\n      index = highlighted - 1\n    } else if (event.keyCode === 13 && highlighted > -1) {\n      // enter\n      setSelected(index)\n    }\n\n    setHighlighted(index)\n  }\n\n  const handleFocus = (index) => {\n    setHighlighted(index)\n  }\n\n  const handleMouseOver = (index) => {\n    setHighlighted(index)\n  }\n\n  const handleClick = (index) => {\n    setSelected(index)\n  }\n\n  return (\n    <View display=\"block\" width=\"300px\" shadow=\"above\">\n      <Options\n        onKeyDown={handleKeyDown}\n        onMouseOut={() => setHighlighted(-1)}\n        tabIndex=\"0\"\n      >\n        {options.map((option, index) => {\n          let variant = 'default'\n          if (highlighted === index) {\n            variant = 'highlighted'\n          } else if (selected === index) {\n            variant = 'selected'\n          }\n\n          return (\n            <Options.Item\n              key={option}\n              variant={variant}\n              tabIndex=\"-1\"\n              onMouseOver={(e) => handleMouseOver(index)}\n              onFocus={() => handleFocus(index)}\n              onClick={() => handleClick(index)}\n            >\n              {option}\n            </Options.Item>\n          )\n        })}\n      </Options>\n    </View>\n  )\n}\n\nrender(\n  <Example\n    options={[\n      'Option one',\n      'Option two',\n      'Option three',\n      'Option four',\n      'Option five'\n    ]}\n  />\n)\n```\n\nYou can recolor the text and the background of the items for their `default`, `highlighted` and `selected` variants.\n\nBy default, the icons in the `Option.Item` have the same color as the text. If you want to set the color of the icon separately, pass a function to the `renderBeforeLabel` or `renderAfterLabel` prop. This function will have a `props` parameter, so you can access the properties of that `Option.Item` (e.g. the current `variant`). The available props are: `[ variant, as, role, children ]`.\n\n```js\n---\ntype: example\n---\nconst Example = ({ options }) => {\n  const [highlighted, setHighlighted] = useState(-1)\n  const [selected, setSelected] = useState(-1)\n\n  const handleKeyDown = (event) => {\n    let index = highlighted\n\n    if (event.keyCode === 40 && highlighted < options.length - 1) {\n      // down arrow\n      event.preventDefault()\n      index = highlighted + 1\n    } else if (event.keyCode === 38 && highlighted > 0) {\n      // up arrow\n      event.preventDefault()\n      index = highlighted - 1\n    } else if (event.keyCode === 13 && highlighted > -1) {\n      // enter\n      setSelected(index)\n    }\n\n    setHighlighted(index)\n  }\n\n  const handleFocus = (event, index) => {\n    setHighlighted(index)\n  }\n\n  const handleMouseOver = (event, index) => {\n    setHighlighted(index)\n  }\n\n  const handleClick = (event, index) => {\n    setSelected(index)\n  }\n\n  return (\n    <View display=\"block\" width=\"300px\" shadow=\"above\">\n      <Options\n        onKeyDown={handleKeyDown}\n        onMouseOut={() => setHighlighted(-1)}\n        tabIndex=\"0\"\n      >\n        {options.map((option, index) => {\n          let variant = 'default'\n          if (highlighted === index) {\n            variant = 'highlighted'\n          } else if (selected === index) {\n            variant = 'selected'\n          }\n\n          return (\n            <Options.Item\n              key={option.label}\n              variant={variant}\n              tabIndex=\"-1\"\n              onMouseOver={(e) => handleMouseOver(e, index)}\n              onFocus={(e) => handleFocus(e, index)}\n              onClick={(e) => handleClick(e, index)}\n              {...option.extraProps}\n            >\n              {option.label}\n            </Options.Item>\n          )\n        })}\n      </Options>\n    </View>\n  )\n}\n\nrender(\n  <Example\n    options={[\n      {\n        label: 'Default item',\n        extraProps: {\n          renderBeforeLabel: IconCheckSolid\n        }\n      },\n      {\n        label: 'Text is green',\n        extraProps: {\n          renderBeforeLabel: IconCheckSolid,\n          themeOverride: { color: '#0B874B' }\n        }\n      },\n      {\n        label: 'Highlighted text is black',\n        extraProps: {\n          renderBeforeLabel: IconCheckSolid,\n          themeOverride: { highlightedLabelColor: '#2D3B45' }\n        }\n      },\n      {\n        label: 'Highlighted background is purple',\n        extraProps: {\n          renderBeforeLabel: IconCheckSolid,\n          themeOverride: { highlightedBackground: '#BF32A4' }\n        }\n      },\n      {\n        label: 'Only the icon is red',\n        extraProps: {\n          renderBeforeLabel: (props) => {\n            return (\n              <IconCheckSolid\n                {...(props.variant === 'default' && { color: 'warning' })}\n              />\n            )\n          }\n        }\n      }\n    ]}\n  />\n)\n```\n\nAdditional/secondary text can be added via the `description` prop, and the ARIA role of it can be set with the `descriptionRole` prop.\n\nFor longer, multi-line options the problem of the vertical alignment comes up. The content of the `renderBeforeLabel` and `renderAfterLabel` props are vertically centered by default. This can be changed with the `beforeLabelContentVAlign` and `afterLabelContentVAlign` props.\n\n```js\n---\ntype: example\n---\nconst Example = () => {\n  const [highlighted, setHighlighted] = useState(-1)\n\n  const handleMouseOver = (index) => {\n    setHighlighted(index)\n  }\n\n  return (\n    <View display=\"block\" width=\"300px\">\n      <Options onMouseOut={() => setHighlighted(-1)}>\n        <Options.Item\n          onMouseOver={() => handleMouseOver(1)}\n          variant={highlighted === 1 ? 'highlighted' : 'default'}\n          description=\"Curabitur fringilla, urna ut efficitur molestie, nibh lacus tincidunt elit, ut tempor ipsum nunc sit amet massa.\"\n          renderBeforeLabel={IconCheckSolid}\n          renderAfterLabel={IconArrowOpenEndSolid}\n          beforeLabelContentVAlign=\"start\"\n          afterLabelContentVAlign=\"start\"\n        >\n          Option one\n        </Options.Item>\n        <Options.Item\n          onMouseOver={() => handleMouseOver(2)}\n          variant={highlighted === 2 ? 'highlighted' : 'default'}\n          description=\"Curabitur fringilla, urna ut efficitur molestie, nibh lacus tincidunt elit, ut tempor ipsum nunc sit amet massa.\"\n          renderBeforeLabel={IconCheckSolid}\n          renderAfterLabel={IconArrowOpenEndSolid}\n          beforeLabelContentVAlign=\"center\"\n          afterLabelContentVAlign=\"center\"\n        >\n          Option two\n        </Options.Item>\n        <Options.Item\n          onMouseOver={() => handleMouseOver(3)}\n          variant={highlighted === 3 ? 'highlighted' : 'default'}\n          description=\"Curabitur fringilla, urna ut efficitur molestie, nibh lacus tincidunt elit, ut tempor ipsum nunc sit amet massa.\"\n          renderBeforeLabel={IconCheckSolid}\n          renderAfterLabel={IconArrowOpenEndSolid}\n          beforeLabelContentVAlign=\"end\"\n          afterLabelContentVAlign=\"end\"\n        >\n          Option three\n        </Options.Item>\n      </Options>\n    </View>\n  )\n}\n\nrender(<Example />)\n```\n\nProviding a `href` prop will render the option as `<a>` link element.\n\n**WARNING!** Since `Options` is a view-only component, you have to make sure it is accessible, and if set the variant to disabled, disable the links as well!\n\n```js\n---\ntype: example\n---\nconst Example = () => {\n  const [highlighted, setHighlighted] = useState(-1)\n\n  const handleMouseOver = (index) => {\n    setHighlighted(index)\n  }\n\n  return (\n    <View display=\"block\" width=\"300px\">\n      <Options onMouseOut={() => setHighlighted(-1)}>\n        <Options.Item\n          onMouseOver={() => handleMouseOver(1)}\n          variant={highlighted === 1 ? 'highlighted' : 'default'}\n          href=\"/\"\n        >\n          Link one\n        </Options.Item>\n        <Options.Item\n          onMouseOver={() => handleMouseOver(2)}\n          variant={highlighted === 2 ? 'highlighted' : 'default'}\n          href=\"/\"\n        >\n          Link two\n        </Options.Item>\n        <Options.Item\n          onMouseOver={() => handleMouseOver(3)}\n          variant={highlighted === 3 ? 'highlighted' : 'default'}\n          variant=\"disabled\"\n          aria-disabled=\"true\"\n          onClick={(e) => {\n            e.preventDefault()\n          }}\n          href=\"/\"\n        >\n          Link three\n        </Options.Item>\n      </Options>\n    </View>\n  )\n}\n\nrender(<Example />)\n```\n","displayName":"Options","methods":[{"name":"handleRef","docblock":null,"modifiers":[],"params":[{"name":"el","optional":false,"type":{"name":"union","raw":"Element | null","elements":[{"name":"Element"},{"name":"null"}]}}],"returns":null},{"name":"childAs","docblock":null,"modifiers":["get"],"params":[],"returns":null},{"name":"renderLabel","docblock":null,"modifiers":[],"params":[],"returns":null},{"name":"renderSubList","docblock":null,"modifiers":[],"params":[{"name":"subOptions","optional":false,"type":{"name":"ComponentElement","elements":[{"name":"intersection","raw":"OptionsOwnProps &\nWithStyleProps<OptionsTheme, OptionsStyle> &\nOtherHTMLAttributes<OptionsOwnProps> &\nWithDeterministicIdProps","elements":[{"name":"signature","type":"object","raw":"{\n  /**\n   * Element type to render as\n   */\n  as?: AsElementType\n  /**\n   * The aria role of the element\n   */\n  role?: string\n  /**\n   * The the actual list element\n   */\n  elementRef?: (element: Element | null) => void\n  /**\n   * Content to render as a label. Mostly for when the component is nested\n   */\n  renderLabel?: Renderable\n\n  //TODO children has to be typed better\n  //e.g.: ChildrenPropTypes.oneOf(['Options', 'Item', 'Separator']))\n  children?: React.ReactNode\n}","signature":{"properties":[{"key":"as","value":{"name":"union","raw":"keyof JSX.IntrinsicElements | ComponentType<P>","elements":[{"name":"JSX.IntrinsicElements"},{"name":"ComponentType","elements":[{"name":"P"}],"raw":"ComponentType<P>"}],"required":false},"description":"Element type to render as"},{"key":"role","value":{"name":"string","required":false},"description":"The aria role of the element"},{"key":"elementRef","value":{"name":"signature","type":"function","raw":"(element: Element | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"Element | null","elements":[{"name":"Element"},{"name":"null"}]},"name":"element"}],"return":{"name":"void"}},"required":false},"description":"The the actual list element"},{"key":"renderLabel","value":{"name":"union","raw":"| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}],"required":false},"description":"Content to render as a label. Mostly for when the component is nested"},{"key":"children","value":{"name":"ReactReactNode","raw":"React.ReactNode","required":false}}]}},{"name":"WithStyleProps","elements":[{"name":"signature","type":"object","raw":"{\n  labelFontWeight: Typography['fontWeightBold']\n  background: Colors['contrasts']['white1010']\n  labelColor: Colors['contrasts']['grey125125']\n  labelPadding: string | 0\n  nestedLabelPadding: string | 0\n}","signature":{"properties":[{"key":"labelFontWeight","value":{"name":"number","raw":"Typography['fontWeightBold']","required":true}},{"key":"background","value":{"name":"signature['white1010']","raw":"Colors['contrasts']['white1010']","required":true}},{"key":"labelColor","value":{"name":"signature['grey125125']","raw":"Colors['contrasts']['grey125125']","required":true}},{"key":"labelPadding","value":{"name":"union","raw":"string | 0","elements":[{"name":"string"},{"name":"literal","value":"0"}],"required":true}},{"key":"nestedLabelPadding","value":{"name":"union","raw":"string | 0","elements":[{"name":"string"},{"name":"literal","value":"0"}],"required":true}}]}},{"name":"ComponentStyle","elements":[{"name":"union","raw":"'options' | 'list' | 'label'","elements":[{"name":"literal","value":"'options'"},{"name":"literal","value":"'list'"},{"name":"literal","value":"'label'"}]}],"raw":"ComponentStyle<'options' | 'list' | 'label'>"}],"raw":"WithStyleProps<OptionsTheme, OptionsStyle>"},{"name":"intersection","raw":"Omit<Attributes, keyof Props | 'dir'> & { dir?: 'ltr' | 'rtl' }","elements":[{"name":"Omit","elements":[{"name":"unknown"},{"name":"union","raw":"keyof Props | 'dir'","elements":[{"name":"signature","type":"object","raw":"{\n  /**\n   * Element type to render as\n   */\n  as?: AsElementType\n  /**\n   * The aria role of the element\n   */\n  role?: string\n  /**\n   * The the actual list element\n   */\n  elementRef?: (element: Element | null) => void\n  /**\n   * Content to render as a label. Mostly for when the component is nested\n   */\n  renderLabel?: Renderable\n\n  //TODO children has to be typed better\n  //e.g.: ChildrenPropTypes.oneOf(['Options', 'Item', 'Separator']))\n  children?: React.ReactNode\n}","signature":{"properties":[{"key":"as","value":{"name":"union","raw":"keyof JSX.IntrinsicElements | ComponentType<P>","elements":[{"name":"JSX.IntrinsicElements"},{"name":"ComponentType","elements":[{"name":"P"}],"raw":"ComponentType<P>"}],"required":false},"description":"Element type to render as"},{"key":"role","value":{"name":"string","required":false},"description":"The aria role of the element"},{"key":"elementRef","value":{"name":"signature","type":"function","raw":"(element: Element | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"Element | null","elements":[{"name":"Element"},{"name":"null"}]},"name":"element"}],"return":{"name":"void"}},"required":false},"description":"The the actual list element"},{"key":"renderLabel","value":{"name":"union","raw":"| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}],"required":false},"description":"Content to render as a label. Mostly for when the component is nested"},{"key":"children","value":{"name":"ReactReactNode","raw":"React.ReactNode","required":false}}]}},{"name":"literal","value":"'dir'"}]}],"raw":"Omit<Attributes, keyof Props | 'dir'>"},{"name":"signature","type":"object","raw":"{ dir?: 'ltr' | 'rtl' }","signature":{"properties":[{"key":"dir","value":{"name":"union","raw":"'ltr' | 'rtl'","elements":[{"name":"literal","value":"'ltr'"},{"name":"literal","value":"'rtl'"}],"required":false}}]}}]},{"name":"WithDeterministicIdProps"}]},{"name":"Options"}],"raw":"ComponentElement<OptionsProps, Options>","alias":"OptionsChild"}}],"returns":null},{"name":"renderChildren","docblock":null,"modifiers":[],"params":[],"returns":null},{"name":"ariaLabelledby","docblock":null,"modifiers":["get"],"params":[],"returns":null}],"props":{"as":{"required":false,"tsType":{"name":"union","raw":"keyof JSX.IntrinsicElements | ComponentType<P>","elements":[{"name":"JSX.IntrinsicElements"},{"name":"ComponentType","elements":[{"name":"P"}],"raw":"ComponentType<P>"}]},"description":"Element type to render as","defaultValue":{"value":"'span'","computed":false}},"role":{"required":false,"tsType":{"name":"string"},"description":"The aria role of the element","defaultValue":{"value":"'list'","computed":false}},"elementRef":{"required":false,"tsType":{"name":"signature","type":"function","raw":"(element: Element | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"Element | null","elements":[{"name":"Element"},{"name":"null"}]},"name":"element"}],"return":{"name":"void"}}},"description":"The the actual list element","defaultValue":{"value":"() => {}","computed":false}},"renderLabel":{"required":false,"tsType":{"name":"union","raw":"| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}]},"description":"Content to render as a label. Mostly for when the component is nested","defaultValue":{"value":"null","computed":false}},"children":{"required":false,"tsType":{"name":"ReactReactNode","raw":"React.ReactNode"},"description":"","defaultValue":{"value":"null","computed":false}},"dir":{"required":false,"tsType":{"name":"union","raw":"'ltr' | 'rtl'","elements":[{"name":"literal","value":"'ltr'"},{"name":"literal","value":"'rtl'"}]},"description":""}},"category":"components/utilities","relativePath":"packages/ui-options/src/Options/index.tsx","extension":".tsx","srcPath":"packages/ui-options/src/Options/index.tsx","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-options/src/Options/index.tsx","packageName":"@instructure/ui-options","requirePath":"@instructure/ui-options/lib/Options/index","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-options/src/Options/index.tsx').default","esPath":"@instructure/ui-options/es/Options/index","themePath":"packages/ui-options/src/Options/theme.ts","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-options/src/Options/theme.ts","id":"Options","title":"Options"}