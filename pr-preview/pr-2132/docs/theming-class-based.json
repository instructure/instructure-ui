{"description":"\n## Making class-based themed components\n\nMake a component themeable with the [withStyle](#withStyle) decorator. It adds a `makeStyles` function and the generated `styles` object to the decorated Component's props.\n\nImport the style generator (`generateStyle`) from `styles.js` and the component theme generator (`generateComponentTheme`) from `theme.js`, and pass them to the decorator.\n\nCall the `makeStyles` method (available on `this.props`) in the `componentDidMount` and `componentDidUpdate` lifecycle methods to generate the styles object and to keep it properly recalculated on every change.\n\nIn the `render` method, use emotion's `css={this.props.styles.componentName}` syntax to add styles.\n\n```jsx\n---\ntype: code\n---\n// Button/index.js\n\n\nimport { withStyle } from '@instructure/emotion'\nimport generateStyle from './styles'\nimport generateComponentTheme from './theme'\n\n@withStyle(generateStyle, generateComponentTheme)\nclass Button extends React.Component {\n  static propTypes = {\n    // eslint-disable-next-line react/require-default-props\n    makeStyles: PropTypes.func,\n    // eslint-disable-next-line react/require-default-props\n    styles: PropTypes.object\n  }\n\n  componentDidMount() {\n    this.props.makeStyles()\n  }\n\n  componentDidUpdate() {\n    this.props.makeStyles()\n  }\n\n  render() {\n    const { propVal1, styles, ...props } = this.props\n\n    return (\n      <button css={styles.button}>\n        <svg css={styles.icon}>...</svg>\n        ...\n      </button>\n    )\n  }\n}\n\nexport { Button }\nexport default Button\n```\n\nThemeable components inject their themed styles into the document when they are mounted.\n\n### Defining variables\n\nThe themeable component uses the JS variables defined in the `theme.js` file.\n\nFor example, to add a variable for the hover state of a Button component, the `theme.js` file might contain the following:\n\n```js\n---\ntype: code\n---\n// Button/theme.js\nconst generateComponentTheme = (theme) => {\n  const { colors } = theme\n\n  const componentVariables = {\n    background: colors?.blue4570,\n    color: colors?.white1010,\n\n    hoverColor: colors?.blue5782,\n    hoverBackground: colors?.blue1212\n  }\n\n  return componentVariables\n}\nexport default generateComponentTheme\n```\n\nThe arguments to the generator function are the [global theme variables](#canvas). In the above example, we've defined the default theme for the Button component.\n\nThe purpose of the generator function is to take the global variables and apply them as values to the functional component level variables.\nWhen coming up with names for the component level variables, try to make them describe how they are used in the component (vs describing the variable value).\n\n### Supporting multiple themes\n\nIf we want to make the Button transform the global theme variables differently with another theme, (e.g. [canvas-high-contrast](#canvas-high-contrast)) we can make specific styling for that theme:\n\n```js\n---\ntype: code\n---\n// Button/theme.js\nconst generateComponentTheme = (theme) => {\n  const { colors, key: themeName } = theme\n\n  const themeSpecificStyle = {\n    'canvas-high-contrast': {\n      background: colors.white1010\n    }\n  }\n\n  const componentVariables = {\n    background: colors?.blue5782,\n    color: colors?.blue5782,\n\n    hoverColor: colors?.blue4570,\n    hoverBackground: colors?.grey125125\n  }\n\n  return {\n    ...componentVariables,\n    ...themeSpecificStyle[themeName]\n  }\n}\nexport default generateComponentTheme\n```\n\nThis will override the default Button theme and use the global theme variable `colors.blue5782` for the value of its `background` theme variable instead of `colors.white1010`.\n\nThe rest of the variables will pick up from the default Button theme generator (applying the global theme variables from the `canvas-high-contrast` theme).\n\n### Using theme variables in styles.js\n\nIn the `styles.js` file, the `generateStyle` method receives the theme variable object (`componentTheme`) generated by `theme.js`.\n\nAdd your styling for each element in the component, and give them [labels](https://emotion.sh/docs/labels#gatsby-focus-wrapper) for easy readability and targetability. _Naming convention_: similar to [BEM naming convention](#http://getbem.com/naming/), use the name of the component in camelCase for the root element ('button'), and the double underscore suffix for children ('button\\_\\_icon').\n\nUse [Emotion's Object Styles documentation](https://emotion.sh/docs/object-styles) as a guide to add styles.\n\nNote: Don't worry about scoping your CSS variables (the emotion library will take care of that for you):\n\n```js\n---\ntype: code\n---\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  return {\n    button: {\n      label: 'button',\n      background: componentTheme.background,\n      color: componentTheme.color,\n\n      '&:hover': {\n        background: componentTheme.hoverBackground,\n        color: componentTheme.hoverColor\n      }\n    },\n    icon: {\n      label: 'button__icon',\n      display: 'inline-block',\n      fill: 'currentColor'\n    }\n  }\n}\nexport default generateStyle\n```\n\nThe `generateStyle` method also automatically receives all the props of the component, so you can add styling based on them:\n\n```js\n---\ntype: code\n---\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  const { display, isDisabled } = props\n\n  const displayVariants = {\n    inline: {\n      display: 'inline-block'\n    },\n    block: {\n      display: 'block',\n      margin: 0\n    },\n    none: {\n      display: 'none'\n    }\n  }\n\n  return {\n    button: {\n      label: 'button',\n      // ...\n      ...(isDisabled && { opacity: 0.5 }),\n      ...displayVariants[display]\n    }\n    // ...\n  }\n}\nexport default generateStyle\n```\n\nYou can also pass additional variables from the component via the `makeStyles` prop. These can be values from the state or from getters, etc.\n\nNote: don't forget to pass them both in `componentDidMount` and `componentDidUpdate` methods!\n\n```js\n---\ntype: code\n---\n// Button/index.js\nclass Button extends React.Component {\n  static propTypes = {\n    // eslint-disable-next-line react/require-default-props\n    makeStyles: PropTypes.func,\n    // eslint-disable-next-line react/require-default-props\n    styles: PropTypes.object\n  }\n\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      focused: false\n    }\n  }\n\n  componentDidMount() {\n    this.props.makeStyles({\n      focused: this.state.focused,\n      someValue: this.someValue\n    })\n  }\n\n  componentDidUpdate() {\n    this.props.makeStyles({\n      focused: this.state.focused,\n      someValue: this.someValue\n    })\n  }\n\n  get someValue() {\n    return 'some value here'\n  }\n\n  render() {\n    // ...\n  }\n}\n\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  const { focused, someValue } = state\n\n  return {\n    button: {\n      label: 'button',\n      // ...\n      ...(someValue === 'not that value' && { display: 'none' }),\n      ...(focused && {\n        borderWidth: '2px',\n        ...(someValue === 'not that value' && { display: 'block' })\n      })\n    }\n    // ...\n  }\n}\nexport default generateStyle\n```\n\n### Using theme variables in JavaScript\n\nSince the variables are defined in JS you can easily pass them through `styles.js` to access in your component JS.\n\n```js\n---\ntype: code\n---\n// Button/styles.js\nconst generateStyle = (componentTheme, props, state) => {\n  return {\n    button: {\n      label: 'button'\n      // ...\n    },\n    maxWidth: componentTheme.maxWidth\n  }\n}\n\n// Button/index.js\nrender() {\n  const { propVal1, styles, ...props } = this.props\n\n  return (\n    <div maxWidth={styles.maxWidth}>\n      ...\n    </div>\n  )\n}\n```\n","title":"Class-based themed components","category":"Contributor Guides/theming","order":3,"relativePath":"docs/contributor-docs/theming/theming-class-based.md","extension":".md","srcPath":"docs/contributor-docs/theming/theming-class-based.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/docs/contributor-docs/theming/theming-class-based.md","packageName":"@instructure/docs","requirePath":"@instructure/docs/contributor-docs/theming/theming-class-based","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/docs/contributor-docs/theming/theming-class-based.md').default","esPath":"@instructure/docs/contributor-docs/theming/theming-class-based","themePath":"docs/contributor-docs/theming/theming-class-based.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/docs/contributor-docs/theming/theming-class-based.md","id":"theming-class-based"}