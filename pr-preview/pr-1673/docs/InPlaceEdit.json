{"description":"\n`InPlaceEdit` provides the DOM structure to organize the components that participate\nin in-place editing by calling the `renderViewer` and `renderEditor` _render props_\nin the context of the containing DOM sub-tree. It also takes care of wiring up the\nevent handlers required by [`Editable`](#Editable) to make the user interactions work.\n\nAs a controlled component, it is the responsibility of the consumer to maintain some data to make this work.\nEach time `InPlaceEdit` is rendered, you must provide as props:\n\n- the current `mode` prop, which defaults to `'view'`. The app will be notified of\n  changes in mode via the `onChangeMode` function property.\n- the current `value` prop, which primarily serves to trigger a re-render when the value changes\n\nThe view component, as returned by the `renderViewer` property can be anything you wish, but\nwill typically render some formatted text. It is up to the consumer to provide this component with\nthe current value.\n\nThe edit component, as returned by the `renderEditor` property is used to collect the user's\ninput. It is up to the consumer to provide the necessary properties to get the user provided value\n(typically `onChange`), and to provide the current value.\n\nSome components, like [Heading](#Heading) and [Text](#Text) can be made editable by setting their `as` property\nto `input` (and optionally the `type` property). The value of this approach is that the editable version\nwill render in the same style as the view, making for a nice user experience. Other transitions,\n`Text` to `Select` or `DateTimeInput` for example, result in a wholesale change in the component's UI, and will alter\nthe space it consumes in the app.\n\nUse `InPlaceEdit` to edit `Text` using `Text as=\"input\"`. Also demonstrates how you might wish to handle\nthe case when the text is empty. Use the checkbox to switch between inline and block layout.\n\n- ```js\n  class Example extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = {\n        mode: props.mode || 'view',\n        value: 'This is some text',\n        inline: true\n      }\n    }\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    handleChangeMode = (mode) => {\n      this.setState({ mode })\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    handleChange = (event) => {\n      this.setState({ value: event.target.value })\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    renderView = () => (\n      <Text\n        color={this.state.value ? 'primary' : 'secondary'}\n        weight={this.state.value ? 'normal' : 'light'}\n        size=\"large\"\n      >\n        {this.state.value || 'Enter some text'}\n      </Text>\n    )\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        color=\"primary\"\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={this.state.value}\n        onChange={this.handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    renderEditButton = (props) => {\n      props.label = `Edit title \"${this.state.value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    onChangeLayout = (event) => {\n      this.setState({ inline: event.target.checked })\n    }\n\n    render() {\n      return (\n        <View as=\"div\">\n          <InPlaceEdit\n            renderViewer={this.renderView}\n            renderEditor={this.renderEdit}\n            renderEditButton={this.renderEditButton}\n            onChangeMode={this.handleChangeMode}\n            mode={this.state.mode}\n            value={this.state.value}\n            inline={this.state.inline}\n          />\n          <View as=\"div\" margin=\"small 0\">\n            <Checkbox\n              label=\"inline\"\n              checked={this.state.inline}\n              onChange={this.onChangeLayout}\n            />\n          </View>\n        </View>\n      )\n    }\n  }\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('This is some text')\n    const [inline, setInline] = useState(true)\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => (\n      <Text\n        color={value ? 'primary' : 'secondary'}\n        weight={value ? 'normal' : 'light'}\n        size=\"large\"\n      >\n        {value || 'Enter some text'}\n      </Text>\n    )\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        color=\"primary\"\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    const onChangeLayout = (event) => {\n      setInline(event.target.checked)\n    }\n\n    return (\n      <View as=\"div\">\n        <InPlaceEdit\n          renderViewer={renderView}\n          renderEditor={renderEdit}\n          renderEditButton={renderEditButton}\n          onChangeMode={handleChangeMode}\n          mode={mode}\n          value={value}\n          inline={inline}\n        />\n        <View as=\"div\" margin=\"small 0\">\n          <Checkbox label=\"inline\" checked={inline} onChange={onChangeLayout} />\n        </View>\n      </View>\n    )\n  }\n\n  render(<Example />)\n  ```\n\nA readOnly `InPlaceEdit`\n\n- ```js\n  class Example extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = {\n        mode: props.mode || 'view',\n        value: 'This is some text'\n      }\n    }\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    handleChangeMode = (mode) => {\n      this.setState({ mode })\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    handleChange = (event) => {\n      this.setState({ value: event.target.value })\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    renderView = () => <Text size=\"large\">{this.state.value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={this.state.value}\n        onChange={this.handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    renderEditButton = (props) => {\n      props.label = `Edit title \"${this.state.value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    render() {\n      return (\n        <InPlaceEdit\n          readOnly\n          renderViewer={this.renderView}\n          renderEditor={this.renderEdit}\n          renderEditButton={this.renderEditButton}\n          onChangeMode={this.handleChangeMode}\n          mode={this.state.mode}\n          value={this.state.value}\n        />\n      )\n    }\n  }\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('This is some text')\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => <Text size=\"large\">{value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    return (\n      <InPlaceEdit\n        readOnly\n        renderViewer={renderView}\n        renderEditor={renderEdit}\n        renderEditButton={renderEditButton}\n        onChangeMode={handleChangeMode}\n        mode={mode}\n        value={value}\n      />\n    )\n  }\n\n  render(<Example />)\n  ```\n\nTo edit end-justified text, wrap `<InPlaceEdit />` in a\n`<View>` component, as follows:\n\n- ```js\n  class Example extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = {\n        mode: props.mode || 'view',\n        value: 'This is some text'\n      }\n    }\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    handleChangeMode = (mode) => {\n      this.setState({ mode })\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    handleChange = (event) => {\n      this.setState({ value: event.target.value })\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    renderView = () => <Text size=\"large\">{this.state.value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={this.state.value}\n        onChange={this.handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    renderEditButton = (props) => {\n      props.label = `Edit title \"${this.state.value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    render() {\n      return (\n        <View as=\"div\" textAlign=\"end\">\n          <InPlaceEdit\n            renderViewer={this.renderView}\n            renderEditor={this.renderEdit}\n            renderEditButton={this.renderEditButton}\n            onChangeMode={this.handleChangeMode}\n            mode={this.state.mode}\n            value={this.state.value}\n            editButtonPlacement=\"start\"\n          />\n        </View>\n      )\n    }\n  }\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('This is some text')\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => <Text size=\"large\">{value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    return (\n      <View as=\"div\" textAlign=\"end\">\n        <InPlaceEdit\n          renderViewer={renderView}\n          renderEditor={renderEdit}\n          renderEditButton={renderEditButton}\n          onChangeMode={handleChangeMode}\n          mode={mode}\n          value={value}\n          editButtonPlacement=\"start\"\n        />\n      </View>\n    )\n  }\n\n  render(<Example />)\n  ```\n\nSame as the first example, but notifies `Editable`'s `onChange`\nwhen the user has finished editing and the value has changed.\n\n- ```js\n  class Example extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = {\n        mode: props.mode || 'view',\n        value: 'Edit me',\n        onChangeValue: undefined\n      }\n    }\n\n    // typically provided by the application so it can\n    // be notified of value changes when the user is\n    // finished editing\n    onChange = (newValue) => {\n      this.setState({ onChangeValue: newValue })\n    }\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    handleChangeMode = (mode) => {\n      this.setState({ mode })\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    handleChange = (event) => {\n      this.setState({ value: event.target.value })\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    renderView = () => <Text size=\"large\">{this.state.value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={this.state.value}\n        onChange={this.handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    renderEditButton = (props) => {\n      props.label = `Edit title \"${this.state.value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    render() {\n      return (\n        <View as=\"div\">\n          <InPlaceEdit\n            renderViewer={this.renderView}\n            renderEditor={this.renderEdit}\n            renderEditButton={this.renderEditButton}\n            onChangeMode={this.handleChangeMode}\n            mode={this.state.mode}\n            value={this.state.value}\n            onChange={this.onChange}\n          />\n          <div>\n            <Text fontStyle=\"italic\">\n              {this.state.onChangeValue !== undefined\n                ? `onChange said: ${this.state.onChangeValue}`\n                : `You haven't edited me yet!`}\n            </Text>\n          </div>\n        </View>\n      )\n    }\n  }\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('Edit me')\n    const [onChangeValue, setOnChangeValue] = useState(undefined)\n\n    // typically provided by the application so it can\n    // be notified of value changes when the user is\n    // finished editing\n    const onChange = (newValue) => {\n      setOnChangeValue(newValue)\n    }\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => <Text size=\"large\">{value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    return (\n      <View as=\"div\">\n        <InPlaceEdit\n          renderViewer={renderView}\n          renderEditor={renderEdit}\n          renderEditButton={renderEditButton}\n          onChangeMode={handleChangeMode}\n          mode={mode}\n          value={value}\n          onChange={onChange}\n        />\n        <div>\n          <Text fontStyle=\"italic\">\n            {onChangeValue !== undefined\n              ? `onChange said: ${onChangeValue}`\n              : `You haven't edited me yet!`}\n          </Text>\n        </div>\n      </View>\n    )\n  }\n\n  render(<Example />)\n  ```\n","displayName":"InPlaceEdit","methods":[],"props":{"renderViewer":{"type":{"name":"func"},"required":true,"description":"Function to render the view mode component.\nIt is the consumer's responsibility to provide the\ncurrent value or children.\n\nReturn value:\n- element: the viewer DOM sub-tree.","tsType":{"name":"signature","type":"function","raw":"() => React.ReactNode","signature":{"arguments":[],"return":{"name":"ReactReactNode","raw":"React.ReactNode"}}}},"renderEditor":{"type":{"name":"func"},"required":true,"description":"Function to render the edit mode component\nIt is the consumer's responsibility to provide the\ncurrent value, and to attach the appropriate onChange\nevent handler needed to capture the updated value. This\nnew value must then be forwarded to the view mode component.\n\nReturn value:\n- element: the editor DOM sub-tree.","tsType":{"name":"signature","type":"function","raw":"(data: {\n  onBlur: () => void\n  editorRef: (el: HTMLElement | null) => void\n}) => React.ReactNode","signature":{"arguments":[{"type":{"name":"signature","type":"object","raw":"{\n  onBlur: () => void\n  editorRef: (el: HTMLElement | null) => void\n}","signature":{"properties":[{"key":"onBlur","value":{"name":"signature","type":"function","raw":"() => void","signature":{"arguments":[],"return":{"name":"void"}},"required":true}},{"key":"editorRef","value":{"name":"signature","type":"function","raw":"(el: HTMLElement | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"HTMLElement | null","elements":[{"name":"HTMLElement"},{"name":"null"}]},"name":"el"}],"return":{"name":"void"}},"required":true}}]}},"name":"data"}],"return":{"name":"ReactReactNode","raw":"React.ReactNode"}}}},"renderEditButton":{"type":{"name":"func"},"required":true,"description":"Function to render the edit button.\n\nParameters:\n- object: { isVisible, onClick, onFocus, onBlur, buttonRef }\n\nReturn value:\n\n- element:  the edit button DOM sub-tree\n\nIf you choose to use the default edit button, add `label` to the\nincoming `props` parameter and call `InPlaceEdit.renderDefaultEditButton(props)`\n\nIf you choose to render a custom button, attach the on* event handlers\nand set `buttonRef` as a `ref` type property on the `button` element.\n\n`isVisible` is a hint as to whether the button is _typically_ shown,\nbut you're free to ignore it for your use-case.","tsType":{"name":"signature","type":"function","raw":"(props: ExtendedRenderEditButton) => React.ReactNode | null","signature":{"arguments":[{"type":{"name":"signature","type":"object","raw":"{\n  elementRef?: (el: HTMLButtonElement) => void\n  onClick: () => void\n  onFocus: () => void\n  onBlur: () => void\n  isVisible: boolean\n  readOnly?: boolean\n}","signature":{"properties":[{"key":"elementRef","value":{"name":"signature","type":"function","raw":"(el: HTMLButtonElement) => void","signature":{"arguments":[{"type":{"name":"HTMLButtonElement"},"name":"el"}],"return":{"name":"void"}},"required":false}},{"key":"onClick","value":{"name":"signature","type":"function","raw":"() => void","signature":{"arguments":[],"return":{"name":"void"}},"required":true}},{"key":"onFocus","value":{"name":"signature","type":"function","raw":"() => void","signature":{"arguments":[],"return":{"name":"void"}},"required":true}},{"key":"onBlur","value":{"name":"signature","type":"function","raw":"() => void","signature":{"arguments":[],"return":{"name":"void"}},"required":true}},{"key":"isVisible","value":{"name":"boolean","required":true}},{"key":"readOnly","value":{"name":"boolean","required":false}}]}},"name":"props"}],"return":{"name":"union","raw":"React.ReactNode | null","elements":[{"name":"ReactReactNode","raw":"React.ReactNode"},{"name":"null"}]}}}},"mode":{"type":{"name":"enum","value":[{"value":"'view'","computed":false},{"value":"'edit'","computed":false}]},"required":true,"description":"If `'view'`: the view component is rendered,\nif `'edit'`: the edit component is rendered","tsType":{"name":"union","raw":"'view' | 'edit'","elements":[{"name":"literal","value":"'view'"},{"name":"literal","value":"'edit'"}]}},"onChangeMode":{"type":{"name":"func"},"required":true,"description":"Called when the component's mode changes\nParameter:\n- newMode: string","tsType":{"name":"signature","raw":"EditableProps['onChangeMode']"}},"value":{"type":{"name":"any"},"required":false,"description":"The current value.\nThe value is managed by the consuming app, but we need to tell InPlaceEdit\nit's changed or it won't re-render","tsType":{"name":"any"}},"onChange":{"type":{"name":"func"},"required":false,"description":"Called when Editable switches from edit to view mode and the value has changed.\nParameter:\n- value: any","tsType":{"name":"signature","raw":"EditableProps['onChange']"}},"readOnly":{"type":{"name":"bool"},"required":false,"description":"The mode is fixed as 'view'","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"showFocusRing":{"type":{"name":"bool"},"required":false,"description":"Show a focus outline when the input is focused","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}},"editButtonPlacement":{"type":{"name":"enum","value":[{"value":"'start'","computed":false},{"value":"'end'","computed":false}]},"required":false,"description":"Put the edit button before or after the view","tsType":{"name":"union","raw":"'start' | 'end'","elements":[{"name":"literal","value":"'start'"},{"name":"literal","value":"'end'"}]},"defaultValue":{"value":"'end'","computed":false}},"inline":{"type":{"name":"bool"},"required":false,"description":"Render outermost element inline v. block","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}}},"category":"components","relativePath":"packages/ui-editable/src/InPlaceEdit/index.tsx","extension":".tsx","srcPath":"packages/ui-editable/src/InPlaceEdit/index.tsx","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-editable/src/InPlaceEdit/index.tsx","packageName":"@instructure/ui-editable","requirePath":"@instructure/ui-editable/lib/InPlaceEdit/index","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-editable/src/InPlaceEdit/index.tsx').default","esPath":"@instructure/ui-editable/es/InPlaceEdit/index","id":"InPlaceEdit","title":"InPlaceEdit"}