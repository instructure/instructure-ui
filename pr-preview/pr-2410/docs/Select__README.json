{"description":"\n`Select` is an accessible, custom styled combobox component for inputting a variety of data types.\n\n- It behaves similar to [Popover](Popover) but provides additional semantic markup and focus behavior as a form input.\n- It should not be used for navigation or as a list of actions/functions. (see [Menu](Menu)).\n- It can behave like a `<select>` element or implement autocomplete behavior.\n\n> Notes:\n>\n> - Before implementing Select, see if a [SimpleSelect](SimpleSelect) will suffice.\n> - The `id` prop on options must be globally unique, it will be translated to an `id` prop in the DOM.\n\n#### Managing state for a Select\n\n`Select` is a controlled-only component. The consuming app or component must manage any state needed. A variety of request callbacks are provided as prompts for state updates. `onRequestShowOptions`, for example, is fired when `Select` thinks the `isShowingOptions` prop should be updated to `true`. Of course, the consumer can always choose how to react to these callbacks.\n\n```js\n---\ntype: example\n---\n  const SingleSelectExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState(options[0].label)\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(options[0].id)\n    const [announcement, setAnnouncement] = useState(null)\n    const inputRef = useRef()\n\n    const focusInput = () => {\n      if (inputRef.current) {\n        inputRef.current.blur()\n        inputRef.current.focus()\n      }\n    }\n\n    const getOptionById = (queryId) => {\n      return options.find(({ id }) => id === queryId)\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n      if (inputValue || selectedOptionId || options.length === 0) return\n\n      if ('key' in event) {\n        switch (event.key) {\n          case 'ArrowDown':\n            return handleHighlightOption(event, { id: options[0].id })\n          case 'ArrowUp':\n            return handleHighlightOption(event, {\n              id: options[options.length - 1].id\n            })\n        }\n      }\n    }\n\n    const handleHideOptions = (event) => {\n      const option = getOptionById(selectedOptionId)?.label\n      setIsShowingOptions(false)\n      setHighlightedOptionId(null)\n      setSelectedOptionId(selectedOptionId ? option : '')\n      setAnnouncement('List collapsed.')\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const optionsAvailable = `${options.length} options available.`\n      const nowOpen = !isShowingOptions\n        ? `List expanded. ${optionsAvailable}`\n        : ''\n      const option = getOptionById(id)?.label\n      setHighlightedOptionId(id)\n      setInputValue(inputValue)\n      setAnnouncement(`${option} ${nowOpen}`)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      focusInput()\n      const option = getOptionById(id)?.label\n      setSelectedOptionId(id)\n      setInputValue(option)\n      setIsShowingOptions(false)\n      setAnnouncement(`\"${option}\" selected. List collapsed.`)\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Single Select\"\n          assistiveText=\"Use arrow keys to navigate options.\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n          inputRef={(el) => {\n            inputRef.current = el\n          }}\n        >\n          {options.map((option) => {\n            return (\n              <Select.Option\n                id={option.id}\n                key={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n              >\n                {option.label}\n              </Select.Option>\n            )\n          })}\n        </Select>\n      </div>\n    )\n  }\n  render(\n    <View>\n      <SingleSelectExample\n        options={[\n          { id: 'opt1', label: 'Alaska' },\n          { id: 'opt2', label: 'American Samoa' },\n          { id: 'opt3', label: 'Arizona' },\n          { id: 'opt4', label: 'Arkansas' },\n          { id: 'opt5', label: 'California' },\n          { id: 'opt6', label: 'Colorado' },\n          { id: 'opt7', label: 'Connecticut' },\n          { id: 'opt8', label: 'Delaware' },\n          { id: 'opt9', label: 'District Of Columbia' },\n          { id: 'opt10', label: 'Federated States Of Micronesia' },\n          { id: 'opt11', label: 'Florida' },\n          { id: 'opt12', label: 'Georgia (unavailable)' },\n          { id: 'opt13', label: 'Guam' },\n          { id: 'opt14', label: 'Hawaii' },\n          { id: 'opt15', label: 'Idaho' },\n          { id: 'opt16', label: 'Illinois' }\n        ]}\n      />\n    </View>\n  )\n```\n\n#### Providing autocomplete behavior\n\nIt's best practice to always provide autocomplete functionality to help users make a selection. The example below demonstrates one method of filtering options based on user input, but this logic should be customized to what works best for the application.\n\n> Note: Select makes some conditional assumptions about keyboard behavior. For example, if the list is NOT showing, up/down arrow keys and the space key, will show the list. Otherwise, the arrows will navigate options and the space key will type a space character.\n\n```js\n---\ntype: example\n---\n  const AutocompleteExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState('')\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(null)\n    const [filteredOptions, setFilteredOptions] = useState(options)\n    const [announcement, setAnnouncement] = useState(null)\n    const inputRef = useRef()\n\n    const focusInput = () => {\n      if (inputRef.current) {\n        inputRef.current.blur()\n        inputRef.current.focus()\n      }\n    }\n\n    const getOptionById = (queryId) => {\n      return options.find(({ id }) => id === queryId)\n    }\n\n    const getOptionsChangedMessage = (newOptions) => {\n      let message =\n        newOptions.length !== filteredOptions.length\n          ? `${newOptions.length} options available.` // options changed, announce new total\n          : null // options haven't changed, don't announce\n      if (message && newOptions.length > 0) {\n        // options still available\n        if (highlightedOptionId !== newOptions[0].id) {\n          // highlighted option hasn't been announced\n          const option = getOptionById(newOptions[0].id).label\n          message = `${option}. ${message}`\n        }\n      }\n      return message\n    }\n\n    const filterOptions = (value) => {\n      return options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    const matchValue = () => {\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          setInputValue(onlyOption.label)\n          setSelectedOptionId(onlyOption.id)\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n      // allow user to return to empty input and no selection\n      else if (inputValue.length === 0) {\n        setSelectedOptionId(null)\n      }\n      // no match found, return selected option label to input\n      else if (selectedOptionId) {\n        const selectedOption = getOptionById(selectedOptionId)\n        setInputValue(selectedOption.label)\n      }\n      // input value is from highlighted option, not user input\n      // clear input, reset options\n      else if (highlightedOptionId) {\n        if (inputValue === getOptionById(highlightedOptionId).label) {\n          setInputValue('')\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n      setAnnouncement(\n        `List expanded. ${filteredOptions.length} options available.`\n      )\n      if (inputValue || selectedOptionId || options.length === 0) return\n\n      if ('key' in event) {\n        switch (event.key) {\n          case 'ArrowDown':\n            return handleHighlightOption(event, { id: options[0].id })\n          case 'ArrowUp':\n            return handleHighlightOption(event, {\n              id: options[options.length - 1].id\n            })\n        }\n      }\n    }\n\n    const handleHideOptions = (event) => {\n      setIsShowingOptions(false)\n      setHighlightedOptionId(false)\n      setAnnouncement('List collapsed.')\n      matchValue()\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = getOptionById(id)\n      if (!option) return // prevent highlighting of empty option\n      setHighlightedOptionId(id)\n      setInputValue(inputValue)\n      setAnnouncement(option.label)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      focusInput()\n      setSelectedOptionId(id)\n      setInputValue(option.label)\n      setIsShowingOptions(false)\n      setFilteredOptions(options)\n      setAnnouncement(`${option.label} selected. List collapsed.`)\n    }\n\n    const handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = filterOptions(value)\n      setInputValue(value)\n      setFilteredOptions(newOptions)\n      setHighlightedOptionId(newOptions.length > 0 ? newOptions[0].id : null)\n      setIsShowingOptions(true)\n      setSelectedOptionId(value === '' ? null : selectedOptionId)\n      setAnnouncement(getOptionsChangedMessage(newOptions))\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Autocomplete\"\n          assistiveText=\"Type or use arrow keys to navigate options.\"\n          placeholder=\"Start typing to search...\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onInputChange={handleInputChange}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n          renderBeforeInput={<IconUserSolid inline={false} />}\n          renderAfterInput={<IconSearchLine inline={false} />}\n          inputRef={(el) => {\n            inputRef.current = el\n          }}\n        >\n          {filteredOptions.length > 0 ? (\n            filteredOptions.map((option) => {\n              return (\n                <Select.Option\n                  id={option.id}\n                  key={option.id}\n                  isHighlighted={option.id === highlightedOptionId}\n                  isSelected={option.id === selectedOptionId}\n                  isDisabled={option.disabled}\n                  renderBeforeLabel={\n                    !option.disabled ? IconUserSolid : IconUserLine\n                  }\n                >\n                  {!option.disabled\n                    ? option.label\n                    : `${option.label} (unavailable)`}\n                </Select.Option>\n              )\n            })\n          ) : (\n            <Select.Option id=\"empty-option\" key=\"empty-option\">\n              ---\n            </Select.Option>\n          )}\n        </Select>\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <AutocompleteExample\n        options={[\n          { id: 'opt0', label: 'Aaron Aaronson' },\n          { id: 'opt1', label: 'Amber Murphy' },\n          { id: 'opt2', label: 'Andrew Miller' },\n          { id: 'opt3', label: 'Barbara Ward' },\n          { id: 'opt4', label: 'Byron Cranston', disabled: true },\n          { id: 'opt5', label: 'Dennis Reynolds' },\n          { id: 'opt6', label: 'Dee Reynolds' },\n          { id: 'opt7', label: 'Ezra Betterthan' },\n          { id: 'opt8', label: 'Jeff Spicoli' },\n          { id: 'opt9', label: 'Joseph Smith' },\n          { id: 'opt10', label: 'Jasmine Diaz' },\n          { id: 'opt11', label: 'Martin Harris' },\n          { id: 'opt12', label: 'Michael Morgan', disabled: true },\n          { id: 'opt13', label: 'Michelle Rodriguez' },\n          { id: 'opt14', label: 'Ziggy Stardust' }\n        ]}\n      />\n    </View>\n  )\n```\n\n#### Highlighting and selecting options\n\nTo mark an option as \"highlighted\", use the option's `isHighlighted` prop. Note that only one highlighted option is permitted. Similarly, use `isSelected` to mark an option or multiple options as \"selected\". When allowing multiple selections, it's best to render a [Tag](Tag) with [AccessibleContent](AccessibleContent) for each selected option via the `renderBeforeInput` prop.\n\n```js\n---\ntype: example\n---\n  const MultipleSelectExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState('')\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(['opt1', 'opt6'])\n    const [filteredOptions, setFilteredOptions] = useState(options)\n    const [announcement, setAnnouncement] = useState(null)\n    const inputRef = useRef()\n\n    const focusInput = () => {\n      if (inputRef.current) {\n        inputRef.current.blur()\n        inputRef.current.focus()\n      }\n    }\n\n    const getOptionById = (queryId) => {\n      return options.find(({ id }) => id === queryId)\n    }\n\n    const getOptionsChangedMessage = (newOptions) => {\n      let message =\n        newOptions.length !== filteredOptions.length\n          ? `${newOptions.length} options available.` // options changed, announce new total\n          : null // options haven't changed, don't announce\n      if (message && newOptions.length > 0) {\n        // options still available\n        if (highlightedOptionId !== newOptions[0].id) {\n          // highlighted option hasn't been announced\n          const option = getOptionById(newOptions[0].id).label\n          message = `${option}. ${message}`\n        }\n      }\n      return message\n    }\n\n    const filterOptions = (value) => {\n      return options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    const matchValue = () => {\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          setInputValue('')\n          setSelectedOptionId([...selectedOptionId, onlyOption.id])\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n      // input value is from highlighted option, not user input\n      // clear input, reset options\n      else if (highlightedOptionId) {\n        if (inputValue === getOptionById(highlightedOptionId).label) {\n          setInputValue('')\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n\n      if (inputValue || options.length === 0) return\n\n      if ('key' in event) {\n        switch (event.key) {\n          case 'ArrowDown':\n            return handleHighlightOption(event, {\n              id: options.find((option) => !selectedOptionId.includes(option.id))\n                .id\n            })\n          case 'ArrowUp':\n            // Highlight last non-selected option\n            return handleHighlightOption(event, {\n              id: options[\n                options.findLastIndex(\n                  (option) => !selectedOptionId.includes(option.id)\n                )\n              ].id\n            })\n        }\n      }\n    }\n\n    const handleHideOptions = (event) => {\n      setIsShowingOptions(false)\n      matchValue()\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = getOptionById(id)\n      if (!option) return // prevent highlighting empty option\n      setHighlightedOptionId(id)\n      setInputValue(inputValue)\n      setAnnouncement(option.label)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      focusInput()\n      setSelectedOptionId([...selectedOptionId, id])\n      setHighlightedOptionId(null)\n      setFilteredOptions(filterOptions(''))\n      setInputValue('')\n      setIsShowingOptions(false)\n      setAnnouncement(`${option.label} selected. List collapsed.`)\n    }\n\n    const handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = filterOptions(value)\n      setInputValue(value)\n      setFilteredOptions(newOptions)\n      setHighlightedOptionId(newOptions.length > 0 ? newOptions[0].id : null)\n      setIsShowingOptions(true)\n      setAnnouncement(getOptionsChangedMessage(newOptions))\n    }\n\n    const handleKeyDown = (event) => {\n      if ('keyCode' in event && event.keyCode === 8) {\n        // when backspace key is pressed\n        if (inputValue === '' && selectedOptionId.length > 0) {\n          // remove last selected option, if input has no entered text\n          setHighlightedOptionId(null)\n          setSelectedOptionId(selectedOptionId.slice(0, -1))\n        }\n      }\n    }\n\n    // remove a selected option tag\n    const dismissTag = (e, tag) => {\n      // prevent closing of list\n      e.stopPropagation()\n      e.preventDefault()\n\n      const newSelection = selectedOptionId.filter((id) => id !== tag)\n\n      setSelectedOptionId(newSelection)\n      setHighlightedOptionId(null)\n      setAnnouncement(`${getOptionById(tag).label} removed`)\n\n      inputRef.current.focus()\n    }\n\n    const renderTags = () => {\n      return selectedOptionId.map((id, index) => (\n        <Tag\n          dismissible\n          key={id}\n          text={\n            <AccessibleContent alt={`Remove ${getOptionById(id).label}`}>\n              {getOptionById(id).label}\n            </AccessibleContent>\n          }\n          margin={\n            index > 0 ? 'xxx-small xx-small xxx-small 0' : '0 xx-small 0 0'\n          }\n          onClick={(e) => dismissTag(e, id)}\n        />\n      ))\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Multiple Select\"\n          assistiveText=\"Type or use arrow keys to navigate options. Multiple selections allowed.\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          inputRef={(el) => {\n            inputRef.current = el\n          }}\n          onBlur={handleBlur}\n          onInputChange={handleInputChange}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n          onKeyDown={handleKeyDown}\n          renderBeforeInput={selectedOptionId.length > 0 ? renderTags() : null}\n        >\n          {filteredOptions.length > 0 ? (\n            filteredOptions.map((option, index) => {\n              if (selectedOptionId.indexOf(option.id) === -1) {\n                return (\n                  <Select.Option\n                    id={option.id}\n                    key={option.id}\n                    isHighlighted={option.id === highlightedOptionId}\n                  >\n                    {option.label}\n                  </Select.Option>\n                )\n              }\n            })\n          ) : (\n            <Select.Option id=\"empty-option\" key=\"empty-option\">\n              ---\n            </Select.Option>\n          )}\n        </Select>\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <MultipleSelectExample\n        options={[\n          { id: 'opt1', label: 'Alaska' },\n          { id: 'opt2', label: 'American Samoa' },\n          { id: 'opt3', label: 'Arizona' },\n          { id: 'opt4', label: 'Arkansas' },\n          { id: 'opt5', label: 'California' },\n          { id: 'opt6', label: 'Colorado' },\n          { id: 'opt7', label: 'Connecticut' },\n          { id: 'opt8', label: 'Delaware' },\n          { id: 'opt9', label: 'District Of Columbia' },\n          { id: 'opt10', label: 'Federated States Of Micronesia' },\n          { id: 'opt11', label: 'Florida' },\n          { id: 'opt12', label: 'Georgia (unavailable)' },\n          { id: 'opt13', label: 'Guam' },\n          { id: 'opt14', label: 'Hawaii' },\n          { id: 'opt15', label: 'Idaho' },\n          { id: 'opt16', label: 'Illinois' }\n        ]}\n      />\n    </View>\n  )\n```\n\n#### Composing option groups\n\nIn addition to `<Select.Option />` Select also accepts `<Select.Group />` as children. This is meant to serve the same purpose as `<optgroup>` elements. Group only requires you provide a label via its `renderLabel` prop. Groups and their associated options also accept icons or other stylistic additions if needed.\n\n```js\n---\ntype: example\n---\nconst GroupSelectExample = ({ options }) => {\n  const [inputValue, setInputValue] = useState(options['Western'][0].label)\n  const [isShowingOptions, setIsShowingOptions] = useState(false)\n  const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n  const [selectedOptionId, setSelectedOptionId] = useState(\n    options['Western'][0].id\n  )\n  const [announcement, setAnnouncement] = useState(null)\n  const inputRef = useRef()\n\n  const focusInput = () => {\n    if (inputRef.current) {\n      inputRef.current.blur()\n      inputRef.current.focus()\n    }\n  }\n\n  const getOptionById = (id) => {\n    let match = null\n    Object.keys(options).forEach((key, index) => {\n      for (let i = 0; i < options[key].length; i++) {\n        const option = options[key][i]\n        if (id === option.id) {\n          // return group property with the object just to make it easier\n          // to check which group the option belongs to\n          match = { ...option, group: key }\n          break\n        }\n      }\n    })\n    return match\n  }\n\n  const getGroupChangedMessage = (newOption) => {\n    const currentOption = getOptionById(highlightedOptionId)\n    const isNewGroup =\n      !currentOption || currentOption.group !== newOption.group\n    let message = isNewGroup ? `Group ${newOption.group} entered. ` : ''\n    message += newOption.label\n    return message\n  }\n\n  const handleShowOptions = (event) => {\n    setIsShowingOptions(true)\n    setHighlightedOptionId(null)\n    if (inputValue || selectedOptionId || Object.keys(options).length === 0) return\n\n    if ('key' in event) {\n      switch (event.key) {\n        case 'ArrowDown':\n          return handleHighlightOption(event, {\n            id: options[Object.keys(options)[0]][0].id\n          })\n        case 'ArrowUp':\n          return handleHighlightOption(event, {\n            id: Object.values(options).at(-1)?.at(-1)?.id\n          })\n      }\n    }\n  }\n\n  const handleHideOptions = (event) => {\n    setIsShowingOptions(false)\n    setHighlightedOptionId(null)\n    setInputValue(getOptionById(selectedOptionId)?.label)\n  }\n\n  const handleBlur = (event) => {\n    setHighlightedOptionId(null)\n  }\n\n  const handleHighlightOption = (event, { id }) => {\n    event.persist()\n    const newOption = getOptionById(id)\n    setHighlightedOptionId(id)\n    setInputValue(inputValue)\n    setAnnouncement(getGroupChangedMessage(newOption))\n  }\n\n  const handleSelectOption = (event, { id }) => {\n    focusInput()\n    setSelectedOptionId(id)\n    setInputValue(getOptionById(id).label)\n    setIsShowingOptions(false)\n    setAnnouncement(`${getOptionById(id).label} selected.`)\n  }\n\n  const renderLabel = (text, variant) => {\n    return (\n      <span>\n        <Badge\n          type=\"notification\"\n          variant={variant}\n          standalone\n          margin=\"0 x-small xxx-small 0\"\n        />\n        {text}\n      </span>\n    )\n  }\n\n  const renderGroup = () => {\n    return Object.keys(options).map((key, index) => {\n      const badgeVariant = key === 'Eastern' ? 'success' : 'primary'\n      return (\n        <Select.Group\n          key={index}\n          renderLabel={renderLabel(key, badgeVariant)}\n        >\n          {options[key].map((option) => (\n            <Select.Option\n              key={option.id}\n              id={option.id}\n              isHighlighted={option.id === highlightedOptionId}\n              isSelected={option.id === selectedOptionId}\n            >\n              {option.label}\n            </Select.Option>\n          ))}\n        </Select.Group>\n      )\n    })\n  }\n\n  return (\n    <div>\n      <Select\n        renderLabel=\"Group Select\"\n        assistiveText=\"Type or use arrow keys to navigate options.\"\n        inputValue={inputValue}\n        isShowingOptions={isShowingOptions}\n        onBlur={handleBlur}\n        onRequestShowOptions={handleShowOptions}\n        onRequestHideOptions={handleHideOptions}\n        onRequestHighlightOption={handleHighlightOption}\n        onRequestSelectOption={handleSelectOption}\n        renderBeforeInput={\n          <Badge\n            type=\"notification\"\n            variant={\n              getOptionById(selectedOptionId)?.group === 'Eastern'\n                ? 'success'\n                : 'primary'\n            }\n            standalone\n            margin=\"0 0 xxx-small 0\"\n          />\n        }\n        inputRef={(el) => {\n          inputRef.current = el\n        }}\n      >\n        {renderGroup()}\n      </Select>\n    </div>\n  )\n}\n\nrender(\n  <View>\n    <GroupSelectExample\n      options={{\n        Western: [\n          { id: 'opt5', label: 'Alaska' },\n          { id: 'opt6', label: 'California' },\n          { id: 'opt7', label: 'Colorado' },\n          { id: 'opt8', label: 'Idaho' }\n        ],\n        Eastern: [\n          { id: 'opt1', label: 'Alabama' },\n          { id: 'opt2', label: 'Connecticut' },\n          { id: 'opt3', label: 'Delaware' },\n          { id: 'opt4', label: 'Illinois' }\n        ]\n      }}\n    />\n  </View>\n)\n```\n\n##### Using groups with autocomplete on Safari\n\nDue to a WebKit bug if you are using `Select.Group` with autocomplete, the screenreader won't announce highlight/selection changes. This only seems to be an issue in Safari. Here is an example how you can work around that:\n\n```js\n---\ntype: example\n---\nconst GroupSelectAutocompleteExample = ({ options }) => {\n  const [inputValue, setInputValue] = useState('')\n  const [isShowingOptions, setIsShowingOptions] = useState(false)\n  const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n  const [selectedOptionId, setSelectedOptionId] = useState(null)\n  const [filteredOptions, setFilteredOptions] = useState(options)\n  const [announcement, setAnnouncement] = useState(null)\n  const inputRef = useRef()\n\n  const focusInput = () => {\n    if (inputRef.current) {\n      inputRef.current.blur()\n      inputRef.current.focus()\n    }\n  }\n\n  const getOptionById = (id) => {\n    return Object.values(options)\n      .flat()\n      .find((o) => o?.id === id)\n  }\n\n  const filterOptions = (value, options) => {\n    const filteredOptions = {}\n    Object.keys(options).forEach((key) => {\n      filteredOptions[key] = options[key]?.filter((option) =>\n        option.label.toLowerCase().includes(value.toLowerCase())\n      )\n    })\n    const optionsWithoutEmptyKeys = Object.keys(filteredOptions)\n      .filter((k) => filteredOptions[k].length > 0)\n      .reduce((a, k) => ({ ...a, [k]: filteredOptions[k] }), {})\n    return optionsWithoutEmptyKeys\n  }\n\n  const handleShowOptions = (event) => {\n    setIsShowingOptions(true)\n    setHighlightedOptionId(null)\n\n    if (inputValue || selectedOptionId || Object.keys(options).length === 0) return\n\n    if ('key' in event) {\n      switch (event.key) {\n        case 'ArrowDown':\n          return handleHighlightOption(event, {\n            id: options[Object.keys(options)[0]][0].id\n          })\n        case 'ArrowUp':\n          return handleHighlightOption(event, {\n            id: Object.values(options).at(-1)?.at(-1)?.id\n          })\n      }\n    }\n  }\n\n  const handleHideOptions = (event) => {\n    setIsShowingOptions(false)\n    setHighlightedOptionId(null)\n  }\n\n  const handleBlur = (event) => {\n    setHighlightedOptionId(null)\n  }\n\n  const handleHighlightOption = (event, { id }) => {\n    event.persist()\n    const option = getOptionById(id)\n    setTimeout(() => {\n      setAnnouncement(option.label)\n    }, 0)\n    setHighlightedOptionId(id)\n  }\n\n  const handleSelectOption = (event, { id }) => {\n    const option = getOptionById(id)\n    if (!option) return // prevent selecting of empty option\n    focusInput()\n    setSelectedOptionId(id)\n    setInputValue(option.label)\n    setIsShowingOptions(false)\n    setFilteredOptions(options)\n    setAnnouncement(option.label)\n  }\n\n  const handleInputChange = (event) => {\n    const value = event.target.value\n    const newOptions = filterOptions(value, options)\n    setInputValue(value)\n    setFilteredOptions(newOptions)\n    setHighlightedOptionId(newOptions.length > 0 ? newOptions[0].id : null)\n    setIsShowingOptions(true)\n    setSelectedOptionId(value === '' ? null : selectedOptionId)\n  }\n\n  const renderGroup = () => {\n    return Object.keys(filteredOptions).map((key, index) => {\n      return (\n        <Select.Group key={index} renderLabel={key}>\n          {filteredOptions[key].map((option) => (\n            <Select.Option\n              key={option.id}\n              id={option.id}\n              isHighlighted={option.id === highlightedOptionId}\n              isSelected={option.id === selectedOptionId}\n            >\n              {option.label}\n            </Select.Option>\n          ))}\n        </Select.Group>\n      )\n    })\n  }\n\n  const renderScreenReaderHelper = () => {\n    return (\n      window.safari && (\n        <ScreenReaderContent>\n          <span role=\"alert\" aria-live=\"assertive\">\n            {announcement}\n          </span>\n        </ScreenReaderContent>\n      )\n    )\n  }\n\n  return (\n    <div>\n      <Select\n        placeholder=\"Start typing to search...\"\n        renderLabel=\"Group Select with autocomplete\"\n        assistiveText=\"Type or use arrow keys to navigate options.\"\n        inputValue={inputValue}\n        isShowingOptions={isShowingOptions}\n        onBlur={handleBlur}\n        onInputChange={handleInputChange}\n        onRequestShowOptions={handleShowOptions}\n        onRequestHideOptions={handleHideOptions}\n        onRequestHighlightOption={handleHighlightOption}\n        onRequestSelectOption={handleSelectOption}\n        inputRef={(el) => {\n          inputRef.current = el\n        }}\n      >\n        {renderGroup()}\n      </Select>\n      {renderScreenReaderHelper()}\n    </div>\n  )\n}\n\nrender(\n  <View>\n    <GroupSelectAutocompleteExample\n      options={{\n        Western: [\n          { id: 'opt5', label: 'Alaska' },\n          { id: 'opt6', label: 'California' },\n          { id: 'opt7', label: 'Colorado' },\n          { id: 'opt8', label: 'Idaho' }\n        ],\n        Eastern: [\n          { id: 'opt1', label: 'Alabama' },\n          { id: 'opt2', label: 'Connecticut' },\n          { id: 'opt3', label: 'Delaware' },\n          { id: '4', label: 'Illinois' }\n        ]\n      }}\n    />\n  </View>\n)\n```\n\n#### Asynchronous option loading\n\nIf no results match the user's search, it's recommended to leave `isShowingOptions` as `true` and to display an \"empty option\" as a way of communicating that there are no matches. Similarly, it's helpful to display a [Spinner](Spinner) in an empty option while options load.\n\n```js\n---\ntype: example\n---\nconst AsyncExample = ({ options }) => {\n  const [inputValue, setInputValue] = useState('')\n  const [isShowingOptions, setIsShowingOptions] = useState(false)\n  const [isLoading, setIsLoading] = useState(false)\n  const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n  const [selectedOptionId, setSelectedOptionId] = useState(null)\n  const [selectedOptionLabel, setSelectedOptionLabel] = useState('')\n  const [filteredOptions, setFilteredOptions] = useState([])\n  const [announcement, setAnnouncement] = useState(null)\n  const inputRef = useRef()\n\n  const focusInput = () => {\n    if (inputRef.current) {\n      inputRef.current.blur()\n      inputRef.current.focus()\n    }\n  }\n\n  let timeoutId = null\n\n  const getOptionById = (queryId) => {\n    return filteredOptions.find(({ id }) => id === queryId)\n  }\n\n  const filterOptions = (value) => {\n    return options.filter((option) =>\n      option.label.toLowerCase().startsWith(value.toLowerCase())\n    )\n  }\n\n  const matchValue = () => {\n    // an option matching user input exists\n    if (filteredOptions.length === 1) {\n      const onlyOption = filteredOptions[0]\n      // automatically select the matching option\n      if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n        setInputValue(onlyOption.label)\n        setSelectedOptionId(onlyOption.id)\n        return\n      }\n    }\n    // allow user to return to empty input and no selection\n    if (inputValue.length === 0) {\n      setSelectedOptionId(null)\n      setFilteredOptions([])\n      return\n    }\n    // no match found, return selected option label to input\n    if (selectedOptionId) {\n      setInputValue(selectedOptionLabel)\n      return\n    }\n  }\n\n  const handleShowOptions = (event) => {\n    setIsShowingOptions(true)\n  }\n\n  const handleHideOptions = (event) => {\n    setIsShowingOptions(false)\n    setHighlightedOptionId(null)\n    setAnnouncement('List collapsed.')\n    matchValue()\n  }\n\n  const handleBlur = (event) => {\n    setHighlightedOptionId(null)\n  }\n\n  const handleHighlightOption = (event, { id }) => {\n    event.persist()\n    const option = getOptionById(id)\n    if (!option) return // prevent highlighting of empty option\n\n    setHighlightedOptionId(id)\n    setInputValue(inputValue)\n    setAnnouncement(option.label)\n  }\n\n  const handleSelectOption = (event, { id }) => {\n    const option = getOptionById(id)\n    if (!option) return // prevent selecting of empty option\n    focusInput()\n    setSelectedOptionId(id)\n    setSelectedOptionLabel(option.label)\n    setInputValue(option.label)\n    setIsShowingOptions(false)\n    setAnnouncement(`${option.label} selected. List collapsed.`)\n    setFilteredOptions([getOptionById(id)])\n  }\n\n  const handleInputChange = (event) => {\n    const value = event.target.value\n    clearTimeout(timeoutId)\n\n    if (!value || value === '') {\n      setIsLoading(false)\n      setInputValue(value)\n      setIsShowingOptions(true)\n      setSelectedOptionId(null)\n      setSelectedOptionLabel(null)\n      setFilteredOptions([])\n    } else {\n      setIsLoading(true)\n      setInputValue(value)\n      setIsShowingOptions(true)\n      setFilteredOptions([])\n      setHighlightedOptionId(null)\n      setAnnouncement('Loading options.')\n\n      timeoutId = setTimeout(() => {\n        const newOptions = filterOptions(value)\n        setFilteredOptions(newOptions)\n        setIsLoading(false)\n        setAnnouncement(`${newOptions.length} options available.`)\n      }, 1500)\n    }\n  }\n\n  return (\n    <div>\n      <Select\n        renderLabel=\"Async Select\"\n        assistiveText=\"Type to search\"\n        inputValue={inputValue}\n        isShowingOptions={isShowingOptions}\n        onBlur={handleBlur}\n        onInputChange={handleInputChange}\n        onRequestShowOptions={handleShowOptions}\n        onRequestHideOptions={handleHideOptions}\n        onRequestHighlightOption={handleHighlightOption}\n        onRequestSelectOption={handleSelectOption}\n        inputRef={(el) => {\n          inputRef.current = el\n        }}\n      >\n        {filteredOptions.length > 0 ? (\n          filteredOptions.map((option) => {\n            return (\n              <Select.Option\n                id={option.id}\n                key={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n                isDisabled={option.disabled}\n                renderBeforeLabel={\n                  !option.disabled ? IconUserSolid : IconUserLine\n                }\n              >\n                {option.label}\n              </Select.Option>\n            )\n          })\n        ) : (\n          <Select.Option id=\"empty-option\" key=\"empty-option\">\n            {isLoading ? (\n              <Spinner renderTitle=\"Loading\" size=\"x-small\" />\n            ) : inputValue !== '' ? (\n              'No results'\n            ) : (\n              'Type to search'\n            )}\n          </Select.Option>\n        )}\n      </Select>\n    </div>\n  )\n}\n\nrender(\n  <View>\n    <AsyncExample\n      options={[\n        { id: 'opt0', label: 'Aaron Aaronson' },\n        { id: 'opt1', label: 'Amber Murphy' },\n        { id: 'opt2', label: 'Andrew Miller' },\n        { id: 'opt3', label: 'Barbara Ward' },\n        { id: 'opt4', label: 'Byron Cranston', disabled: true },\n        { id: 'opt5', label: 'Dennis Reynolds' },\n        { id: 'opt6', label: 'Dee Reynolds' },\n        { id: 'opt7', label: 'Ezra Betterthan' },\n        { id: 'opt8', label: 'Jeff Spicoli' },\n        { id: 'opt9', label: 'Joseph Smith' },\n        { id: 'opt10', label: 'Jasmine Diaz' },\n        { id: 'opt11', label: 'Martin Harris' },\n        { id: 'opt12', label: 'Michael Morgan', disabled: true },\n        { id: 'opt13', label: 'Michelle Rodriguez' },\n        { id: 'opt14', label: 'Ziggy Stardust' }\n      ]}\n    />\n  </View>\n)\n```\n\n### Icons\n\nTo display icons (or other elements) before or after an option, pass it via the `renderBeforeLabel` and `renderAfterLabel` prop to `Select.Option`. You can pass a function as well, which will have a `props` parameter, so you can access the properties of that `Select.Option` (e.g. if it is currently `isHighlighted`). The available props are: `[ id, isDisabled, isSelected, isHighlighted, children ]`.\n\n```js\n---\ntype: example\n---\nconst SingleSelectExample = ({ options }) => {\n  const [inputValue, setInputValue] = useState(options[0].label)\n  const [isShowingOptions, setIsShowingOptions] = useState(false)\n  const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n  const [selectedOptionId, setSelectedOptionId] = useState(options[0].id)\n  const [announcement, setAnnouncement] = useState(null)\n  const inputRef = useRef()\n\n  const focusInput = () => {\n    if (inputRef.current) {\n      inputRef.current.blur()\n      inputRef.current.focus()\n    }\n  }\n\n  const getOptionById = (queryId) => {\n    return options.find(({ id }) => id === queryId)\n  }\n\n  const handleShowOptions = (event) => {\n    setIsShowingOptions(true)\n\n    if (inputValue || selectedOptionId || options.length === 0) return\n\n    if ('key' in event) {\n      switch (event.key) {\n        case 'ArrowDown':\n          return handleHighlightOption(event, { id: options[0].id })\n        case 'ArrowUp':\n          return handleHighlightOption(event, {\n            id: options[options.length - 1].id\n          })\n      }\n    }\n  }\n\n  const handleHideOptions = (event) => {\n    const option = getOptionById(selectedOptionId)?.label\n    setIsShowingOptions(false)\n    setHighlightedOptionId(null)\n    setInputValue(selectedOptionId ? option : '')\n    setAnnouncement('List collapsed.')\n  }\n\n  const handleBlur = (event) => {\n    setHighlightedOptionId(null)\n  }\n\n  const handleHighlightOption = (event, { id }) => {\n    event.persist()\n    const optionsAvailable = `${options.length} options available.`\n    const nowOpen = !isShowingOptions\n      ? `List expanded. ${optionsAvailable}`\n      : ''\n    const option = getOptionById(id).label\n    setHighlightedOptionId(id)\n    setInputValue(inputValue)\n    setAnnouncement(`${option} ${nowOpen}`)\n  }\n\n  const handleSelectOption = (event, { id }) => {\n    const option = getOptionById(id).label\n    focusInput()\n    setSelectedOptionId(id)\n    setInputValue(option)\n    setIsShowingOptions(false)\n    setAnnouncement(`\"${option}\" selected. List collapsed.`)\n  }\n\n  return (\n    <div>\n      <Select\n        renderLabel=\"Option Icons\"\n        assistiveText=\"Use arrow keys to navigate options.\"\n        inputValue={inputValue}\n        isShowingOptions={isShowingOptions}\n        onBlur={handleBlur}\n        onRequestShowOptions={handleShowOptions}\n        onRequestHideOptions={handleHideOptions}\n        onRequestHighlightOption={handleHighlightOption}\n        onRequestSelectOption={handleSelectOption}\n        inputRef={(el) => {\n          inputRef.current = el\n        }}\n      >\n        {options.map((option) => {\n          return (\n            <Select.Option\n              id={option.id}\n              key={option.id}\n              isHighlighted={option.id === highlightedOptionId}\n              isSelected={option.id === selectedOptionId}\n              renderBeforeLabel={option.renderBeforeLabel}\n            >\n              {option.label}\n            </Select.Option>\n          )\n        })}\n      </Select>\n    </div>\n  )\n}\n\nrender(\n  <View>\n    <SingleSelectExample\n      options={[\n        {\n          id: 'opt1',\n          label: 'Text',\n          renderBeforeLabel: 'XY'\n        },\n        {\n          id: 'opt2',\n          label: 'Icon',\n          renderBeforeLabel: <IconCheckSolid />\n        },\n        {\n          id: 'opt3',\n          label: 'Colored Icon',\n          renderBeforeLabel: (props) => {\n            let color = 'brand'\n            if (props.isHighlighted) color = 'primary-inverse'\n            if (props.isSelected) color = 'primary'\n            if (props.isDisabled) color = 'warning'\n            return <IconInstructureSolid color={color} />\n          }\n        }\n      ]}\n    />\n  </View>\n)\n```\n\n#### Providing assistive text for screen readers\n\nIt's important to ensure screen reader users receive instruction and feedback while interacting with a `Select`, but screen reader support for the `combobox` role varies. The `assistiveText` prop should always be used to explain how a keyboard user can make a selection. Additionally, a live region should be updated with feedback as the component is interacted with, such as when options are filtered or highlighted. Using an [Alert](Alert) with the `screenReaderOnly` prop is the easiest way to do this.\n\n> Note: This component uses a native `input` field to render the selected value. When it's included in a native HTML `form`, the text value will be sent to the backend instead of anything specified in the `value` field of the `Select.Option`-s. We do not recommend to use this component this way, rather write your own code that collects information and sends it to the backend.\n\n```js\n---\ntype: embed\n---\n<Guidelines>\n  <Figure recommendation=\"a11y\" title=\"Accessibility\">\n    <Figure.Item>To ensure Select is accessible for iOS VoiceOver users, the input fieldâ€™s focus must be blurred and then reapplied after selecting an option and closing the listbox. The examples above demonstrate this behavior.\n    </Figure.Item>\n    <Figure.Item>If no option is selected initially, pressing the down arrow should open the listbox and move focus to the first option, while pressing up should move focus to the last item. You can see this behavior in the examples above.\n    </Figure.Item>\n  </Figure>\n</Guidelines>\n```\n","describes":"Select","relativePath":"packages/ui-select/src/Select/README.md","extension":".md","srcPath":"packages/ui-select/src/Select/README.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-select/src/Select/README.md","packageName":"@instructure/ui-select","requirePath":"@instructure/ui-select/lib/Select/README","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-select/src/Select/README.md').default","esPath":"@instructure/ui-select/es/Select/README","themePath":"packages/ui-select/src/Select/README.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-select/src/Select/README.md","id":"Select__README","title":"Select__README"}