{"description":"\n`InPlaceEdit` provides the DOM structure to organize the components that participate\nin in-place editing by calling the `renderViewer` and `renderEditor` _render props_\nin the context of the containing DOM sub-tree. It also takes care of wiring up the\nevent handlers required by [`Editable`](Editable) to make the user interactions work.\n\nAs a controlled component, it is the responsibility of the consumer to maintain some data to make this work.\nEach time `InPlaceEdit` is rendered, you must provide as props:\n\n- the current `mode` prop, which defaults to `'view'`. The app will be notified of\n  changes in mode via the `onChangeMode` function property.\n- the current `value` prop, which primarily serves to trigger a re-render when the value changes\n\nThe view component, as returned by the `renderViewer` property can be anything you wish, but\nwill typically render some formatted text. It is up to the consumer to provide this component with\nthe current value.\n\nThe edit component, as returned by the `renderEditor` property is used to collect the user's\ninput. It is up to the consumer to provide the necessary properties to get the user provided value\n(typically `onChange`), and to provide the current value.\n\nSome components, like [Heading](Heading) and [Text](Text) can be made editable by setting their `as` property\nto `input` (and optionally the `type` property). The value of this approach is that the editable version\nwill render in the same style as the view, making for a nice user experience. Other transitions,\n`Text` to `Select` or `DateTimeInput` for example, result in a wholesale change in the component's UI, and will alter\nthe space it consumes in the app.\n\nUse `InPlaceEdit` to edit `Text` using `Text as=\"input\"`. Also demonstrates how you might wish to handle\nthe case when the text is empty. Use the checkbox to switch between inline and block layout.\n\n```js\n---\ntype: example\n---\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('This is some text')\n    const [inline, setInline] = useState(true)\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => (\n      <Text\n        color={value ? 'primary' : 'secondary'}\n        weight={value ? 'normal' : 'light'}\n        size=\"large\"\n      >\n        {value || 'Enter some text'}\n      </Text>\n    )\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        color=\"primary\"\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    const onChangeLayout = (event) => {\n      setInline(event.target.checked)\n    }\n\n    return (\n      <View as=\"div\">\n        <InPlaceEdit\n          renderViewer={renderView}\n          renderEditor={renderEdit}\n          renderEditButton={renderEditButton}\n          onChangeMode={handleChangeMode}\n          mode={mode}\n          value={value}\n          inline={inline}\n        />\n        <View as=\"div\" margin=\"small 0\">\n          <Checkbox label=\"inline\" checked={inline} onChange={onChangeLayout} />\n        </View>\n      </View>\n    )\n  }\n\n  render(<Example />)\n```\n\nA readOnly `InPlaceEdit`\n\n```js\n---\ntype: example\n---\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('This is some text')\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => <Text size=\"large\">{value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    return (\n      <InPlaceEdit\n        readOnly\n        renderViewer={renderView}\n        renderEditor={renderEdit}\n        renderEditButton={renderEditButton}\n        onChangeMode={handleChangeMode}\n        mode={mode}\n        value={value}\n      />\n    )\n  }\n\n  render(<Example />)\n```\n\nTo edit end-justified text, wrap `<InPlaceEdit />` in a\n`<View>` component, as follows:\n\n```js\n---\ntype: example\n---\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('This is some text')\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => <Text size=\"large\">{value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    return (\n      <View as=\"div\" textAlign=\"end\">\n        <InPlaceEdit\n          renderViewer={renderView}\n          renderEditor={renderEdit}\n          renderEditButton={renderEditButton}\n          onChangeMode={handleChangeMode}\n          mode={mode}\n          value={value}\n          editButtonPlacement=\"start\"\n        />\n      </View>\n    )\n  }\n\n  render(<Example />)\n```\n\nSame as the first example, but notifies `Editable`'s `onChange`\nwhen the user has finished editing and the value has changed.\n\n```js\n---\ntype: example\n---\n  const Example = (props) => {\n    const [mode, setMode] = useState(props.mode || 'view')\n    const [value, setValue] = useState('Edit me')\n    const [onChangeValue, setOnChangeValue] = useState(undefined)\n\n    // typically provided by the application so it can\n    // be notified of value changes when the user is\n    // finished editing\n    const onChange = (newValue) => {\n      setOnChangeValue(newValue)\n    }\n\n    // You must provide this to Editable to be\n    // notified of mode changes\n    const handleChangeMode = (mode) => {\n      setMode(mode)\n    }\n\n    // You attach an event handler to your edit component\n    // to be notified of value changes from user interactions\n    const handleChange = (event) => {\n      setValue(event.target.value)\n    }\n\n    // Renders the view component\n    // Be sure to give it the current value\n    const renderView = () => <Text size=\"large\">{value}</Text>\n\n    // Renders the edit component.\n    // You have to forward the props on, which\n    // includes an onBlur property to help manage\n    // the mode changes.\n    // Be sure to give it the current value\n    const renderEdit = ({ onBlur, editorRef }) => (\n      <Text\n        size=\"large\"\n        as=\"input\"\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        aria-label=\"The title\"\n        onBlur={onBlur}\n        elementRef={editorRef}\n      />\n    )\n\n    // Renders the edit button.\n    // Leverage the default implementation provided by InPlaceEdit\n    const renderEditButton = (props) => {\n      props.label = `Edit title \"${value}\"`\n      return InPlaceEdit.renderDefaultEditButton(props)\n    }\n\n    return (\n      <View as=\"div\">\n        <InPlaceEdit\n          renderViewer={renderView}\n          renderEditor={renderEdit}\n          renderEditButton={renderEditButton}\n          onChangeMode={handleChangeMode}\n          mode={mode}\n          value={value}\n          onChange={onChange}\n        />\n        <div>\n          <Text fontStyle=\"italic\">\n            {onChangeValue !== undefined\n              ? `onChange said: ${onChangeValue}`\n              : `You haven't edited me yet!`}\n          </Text>\n        </div>\n      </View>\n    )\n  }\n\n  render(<Example />)\n```\n","describes":"InPlaceEdit","relativePath":"packages/ui-editable/src/InPlaceEdit/README.md","extension":".md","srcPath":"packages/ui-editable/src/InPlaceEdit/README.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-editable/src/InPlaceEdit/README.md","packageName":"@instructure/ui-editable","requirePath":"@instructure/ui-editable/lib/InPlaceEdit/README","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-editable/src/InPlaceEdit/README.md').default","esPath":"@instructure/ui-editable/es/InPlaceEdit/README","themePath":"packages/ui-editable/src/InPlaceEdit/README.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-editable/src/InPlaceEdit/README.md","id":"InPlaceEdit__README","title":"InPlaceEdit__README"}