{"description":"\nThe `Editable` component exists to support in-place editing of content on the page.\nPerhaps you have a page with some text, say the heading, that you'd like to let the user\nedit right there in-place. `Editable` manages the user's interactions which will flip\nthe rendering from the view mode to the edit mode in an accessible way. It is then just up\nto the consumer of `Editable` to provide _render properties_ which return the view component\nand the edit component.\n\nWhere `Editable` provides the state management and user interactions, it is not its\nresponsibility to provide the DOM structure to layout the component on the page. We provide\na standard implementation of that in [`InPlaceEdit`](/#InPlaceEdit), which is where you\nwill find examples.\n\nUsing `Editable` gives you complete control, over how in-place editing\nshould look.\n\n```js\n---\ntype: example\n---\nconst Example = (props) => {\n  const [mode, setMode] = useState(props.mode || 'view')\n  const [value, setValue] = useState(props.value || '')\n  const [readOnly, setReadOnly] = useState(false)\n\n  const renderButton = ({\n    isVisible,\n    onClick,\n    onFocus,\n    onBlur,\n    buttonRef\n  }) => {\n    if (readOnly) {\n      return null\n    }\n\n    // To correctly handle focus, always return the Button, but\n    // only visible if isVisible (if you want the UI to work in the standard way)\n    return (\n      <span style={{ opacity: isVisible ? 1 : 0 }}>\n        <Button\n          size=\"small\"\n          margin=\"0 0 0 x-small\"\n          onClick={onClick}\n          onFocus={onFocus}\n          onBlur={onBlur}\n          elementRef={buttonRef}\n        >\n          Do it!\n        </Button>\n      </span>\n    )\n  }\n\n  const renderViewer = () => {\n    return <span>{value}</span>\n  }\n\n  const handleValueChange = (event) => {\n    setValue(event.target.value)\n  }\n\n  const handleModeChange = (newMode) => {\n    setMode(newMode)\n  }\n\n  const renderEditor = ({ onBlur, editorRef }) => {\n    return (\n      <input\n        ref={editorRef}\n        onBlur={onBlur}\n        value={value}\n        onChange={handleValueChange}\n      />\n    )\n  }\n\n  const renderMe = ({\n    mode,\n    getContainerProps,\n    getViewerProps,\n    getEditorProps,\n    getEditButtonProps\n  }) => {\n    return (\n      <View {...getContainerProps()}>\n        {mode === 'view' ? renderViewer(getViewerProps()) : null}\n        {mode === 'edit' ? renderEditor(getEditorProps()) : null}\n        {renderButton(getEditButtonProps())}\n      </View>\n    )\n  }\n\n  const onChangeReadOnly = (event) => {\n    setReadOnly(event.target.checked)\n  }\n\n  return (\n    <View as=\"div\">\n      <View as=\"div\" margin=\"0 0 small 0\">\n        <Checkbox\n          size=\"small\"\n          label=\"Read Only\"\n          checked={readOnly}\n          onChange={onChangeReadOnly}\n        />\n      </View>\n      <Editable\n        mode={mode}\n        onChangeMode={handleModeChange}\n        render={renderMe}\n        value={value}\n        readOnly={readOnly}\n      />\n    </View>\n  )\n}\n\nrender(<Example value=\"you can edit me\" />)\n```\n","describes":"Editable","relativePath":"packages/ui-editable/src/Editable/README.md","extension":".md","srcPath":"packages/ui-editable/src/Editable/README.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-editable/src/Editable/README.md","packageName":"@instructure/ui-editable","requirePath":"@instructure/ui-editable/lib/Editable/README","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-editable/src/Editable/README.md').default","esPath":"@instructure/ui-editable/es/Editable/README","themePath":"packages/ui-editable/src/Editable/README.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-editable/src/Editable/README.md","id":"Editable__README","title":"Editable__README"}