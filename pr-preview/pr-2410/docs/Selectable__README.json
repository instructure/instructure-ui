{"description":"\n`Selectable` is a low level utility component that can be used to create combobox widgets. Before composing your own component, make sure an existing component, like [Select](Select), can't be adapted for your use case.\n\n```js\n---\ntype: example\n---\n  const CustomSelect = ({ options, isDisabled }) => {\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(\n      options[0].id\n    )\n    const [selectedOptionId, setSelectedOptionId] = useState(options[0].id)\n    const [inputValue, setInputValue] = useState(options[0].label)\n    const [filteredOptions, setFilteredOptions] = useState(options)\n\n    const rootRef = useRef(null)\n\n    const filterOptions = (value) => {\n      return options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    const matchValue = () => {\n      if (filteredOptions.length === 1) {\n        if (\n          filteredOptions[0].label.toLowerCase() === inputValue.toLowerCase()\n        ) {\n          setInputValue(filteredOptions[0].label)\n          setsSelectedOptionId(filteredOptions[0].id)\n          return\n        }\n      }\n      const index = getOptionIndex(null, selectedOptionId, options)\n      setInputValue(options[index].label)\n    }\n\n    const getInputStyles = () => {\n      return {\n        display: 'block',\n        width: '250px',\n        padding: '5px'\n      }\n    }\n\n    const getListStyles = () => {\n      return {\n        background: 'white',\n        listStyle: 'none',\n        padding: 0,\n        margin: 0,\n        border: isShowingOptions && 'solid 1px lightgray'\n      }\n    }\n\n    const getOptionStyles = (option) => {\n      const selected = selectedOptionId === option.id\n      const highlighted = highlightedOptionId === option.id\n      let background = 'transparent'\n      if (selected) {\n        background = 'lightgray'\n      } else if (highlighted) {\n        background = '#eeeeee'\n      }\n      return {\n        background,\n        padding: '0 10px'\n      }\n    }\n\n    const getOptionIndex = (direction, id, from) => {\n      const options = from ? from : filteredOptions\n      let index\n\n      for (let i = 0; i <= options.length - 1; i++) {\n        if (typeof id === 'undefined') {\n          if (highlightedOptionId === options[i].id) {\n            index = i + direction\n            if (index < 0) {\n              index = 0\n            } else if (index >= options.length - 1) {\n              index = options.length - 1\n            }\n            break\n          }\n        } else {\n          if (id === options[i].id) {\n            index = i\n            break\n          }\n        }\n      }\n      return index\n    }\n\n    const getHandlers = () => {\n      return isDisabled\n        ? {}\n        : {\n            onRequestShowOptions: (e) => {\n              setIsShowingOptions(true)\n              setHighlightedOptionId(filteredOptions[0].id)\n            },\n            onRequestHideOptions: (e) => {\n              const index = getOptionIndex(null, selectedOptionId, options)\n              setIsShowingOptions(false)\n              setInputValue(options[index].label)\n              setFilteredOptions(options)\n              setHighlightedOptionId(null)\n            },\n            onRequestHighlightOption: (e, { id, direction }) => {\n              let index = getOptionIndex(direction, id)\n              setHighlightedOptionId(\n                filteredOptions[index] ? filteredOptions[index].id : null\n              )\n              setInputValue(\n                direction && filteredOptions[index]\n                  ? filteredOptions[index].label\n                  : inputValue\n              )\n            },\n            onRequestSelectOption: (e, { id }) => {\n              const index = getOptionIndex(null, id)\n              setSelectedOptionId(id)\n              setInputValue(filteredOptions[index].label)\n              setFilteredOptions(options)\n              setIsShowingOptions(false)\n              setHighlightedOptionId(null)\n            }\n          }\n    }\n\n    return (\n      <Selectable\n        isShowingOptions={isShowingOptions}\n        highlightedOptionId={highlightedOptionId}\n        selectedOptionId={selectedOptionId ? selectedOptionId : null}\n        {...getHandlers()}\n      >\n        {({\n          getRootProps,\n          getLabelProps,\n          getInputProps,\n          getTriggerProps,\n          getListProps,\n          getOptionProps\n        }) => (\n          <span\n            style={{ display: 'inline-block' }}\n            {...getRootProps({ ref: rootRef })}\n          >\n            <label {...getLabelProps()}>Selectable Example</label>\n            <input\n              style={getInputStyles()}\n              {...getInputProps()}\n              {...getTriggerProps({\n                type: 'text',\n                value: inputValue,\n                onChange: (e) => {\n                  const newOptions = filterOptions(e.target.value)\n                  setInputValue(e.target.valu)\n                  setFilteredOptions(newOptions)\n                  setIsShowingOptions(true)\n                  setHighlightedOptionId(\n                    newOptions[0] ? newOptions[0].id : null\n                  )\n                },\n                onBlur: (e) => {\n                  setFilteredOptions(options)\n                  setHighlightedOptionId(null)\n                  setIsShowingOptions(false)\n                  matchValue()\n                }\n              })}\n            />\n            <ul style={getListStyles()} {...getListProps()}>\n              {isShowingOptions &&\n                filteredOptions.map((option) => (\n                  <li\n                    key={option.id}\n                    style={getOptionStyles(option)}\n                    {...getOptionProps({ id: option.id })}\n                  >\n                    {option.label}\n                  </li>\n                ))}\n            </ul>\n          </span>\n        )}\n      </Selectable>\n    )\n  }\n\n  render(\n    <View>\n      <CustomSelect\n        options={[\n          { id: 'opt0', value: '0', label: 'Alabama' },\n          { id: 'opt1', value: '1', label: 'Alaska' },\n          { id: 'opt2', value: '2', label: 'American Samoa' },\n          { id: 'opt3', value: '3', label: 'Arizona' },\n          { id: 'opt4', value: '4', label: 'Arkansas' },\n          { id: 'opt5', value: '5', label: 'California' },\n          { id: 'opt6', value: '6', label: 'Colorado' },\n          { id: 'opt7', value: '7', label: 'Connecticut' },\n          { id: 'opt8', value: '8', label: 'Delaware' },\n          { id: 'opt9', value: '9', label: 'District Of Columbia' },\n          { id: 'opt10', value: '10', label: 'Federated States Of Micronesia' },\n          { id: 'opt11', value: '11', label: 'Florida' },\n          { id: 'opt12', value: '12', label: 'Georgia' },\n          { id: 'opt13', value: '13', label: 'Guam' },\n          { id: 'opt14', value: '14', label: 'Hawaii' },\n          { id: 'opt15', value: '15', label: 'Idaho' },\n          { id: 'opt16', value: '16', label: 'Illinois' }\n        ]}\n      />\n    </View>\n  )\n```\n\nSelectable has very few opinions about how a combobox component should be composed. It mostly aims to ensure all the proper WAI-ARIA roles and attributes are set on the right elements at the right times. Selectable uses a combination of controllable props and prop getters to set these attributes and provide accessible behavior.\n\n#### Prop getters\n\n`Selectable` provides a number of different prop getters. Each getter is intended to be used with a particular element in your component. `getInputProps` should be used to obtain attributes relevant to the `input` element in a combobox component. `getTriggerProps` should be used for the element responsible for triggering the showing and hiding of the options list. If the `input` element is also the trigger, use both of these prop getters on that element.\n\nThe only getter with a required argument is `getOptionProps` which requires an `id` be provided. However, it's best practice to set any props needed on an element via its prop getter. This just ensures you don't inadvertently override an essential value.\n\n#### Controllable props\n\nThere are several controllable props available. These should be updated to reflect changes to the externally managed state of the combobox component. The `selectedOptionId` prop, for example, specifies which option(s) should be considered \"selected\" when rendered.\n\n#### Request callbacks\n\nA variety of request callbacks are provided as prompts for state updates. They do not actually make any changes to props or state on their own. `onRequestShowOptions`, for example, is fired when `Selectable` thinks its `isShowingOptions` prop should be updated to true. The consumer can always decide if and how to react to these prompts, but utilizing them reduces a lot of the boilerplate combobox logic the consumer would otherwise be responsible for providing.\n","describes":"Selectable","relativePath":"packages/ui-selectable/src/Selectable/README.md","extension":".md","srcPath":"packages/ui-selectable/src/Selectable/README.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-selectable/src/Selectable/README.md","packageName":"@instructure/ui-selectable","requirePath":"@instructure/ui-selectable/lib/Selectable/README","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-selectable/src/Selectable/README.md').default","esPath":"@instructure/ui-selectable/es/Selectable/README","themePath":"packages/ui-selectable/src/Selectable/README.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-selectable/src/Selectable/README.md","id":"Selectable__README","title":"Selectable__README"}