{"description":"\n`Select` is an accessible, custom styled combobox component for inputting a variety of data types.\n\n- It behaves similar to [Popover](#Popover) but provides additional semantic markup and focus behavior as a form input.\n- It should not be used for navigation or as a list of actions/functions. (see [Menu](#Menu)).\n- It can behave like a `<select>` element or implement autocomplete behavior.\n\n> Note: Before implementing Select, see if a [SimpleSelect](#SimpleSelect) will suffice.\n\n#### Managing state for a Select\n\n`Select` is a controlled-only component. The consuming app or component must manage any state needed. A variety of request callbacks are provided as prompts for state updates. `onRequestShowOptions`, for example, is fired when `Select` thinks the `isShowingOptions` prop should be updated to `true`. Of course, the consumer can always choose how to react to these callbacks.\n\n- ```javascript\n  class SingleSelectExample extends React.Component {\n    state = {\n      inputValue: this.props.options[0].label,\n      isShowingOptions: false,\n      highlightedOptionId: null,\n      selectedOptionId: this.props.options[0].id,\n      announcement: null\n    }\n\n    getOptionById(queryId) {\n      return this.props.options.find(({ id }) => id === queryId)\n    }\n\n    handleShowOptions = (event) => {\n      this.setState({\n        isShowingOptions: true\n      })\n    }\n\n    handleHideOptions = (event) => {\n      const { selectedOptionId } = this.state\n      const option = this.getOptionById(selectedOptionId).label\n      this.setState({\n        isShowingOptions: false,\n        highlightedOptionId: null,\n        inputValue: selectedOptionId ? option : '',\n        announcement: 'List collapsed.'\n      })\n    }\n\n    handleBlur = (event) => {\n      this.setState({\n        highlightedOptionId: null\n      })\n    }\n\n    handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const optionsAvailable = `${this.props.options.length} options available.`\n      const nowOpen = !this.state.isShowingOptions\n        ? `List expanded. ${optionsAvailable}`\n        : ''\n      const option = this.getOptionById(id).label\n      this.setState((state) => ({\n        highlightedOptionId: id,\n        inputValue: event.type === 'keydown' ? option : state.inputValue,\n        announcement: `${option} ${nowOpen}`\n      }))\n    }\n\n    handleSelectOption = (event, { id }) => {\n      const option = this.getOptionById(id).label\n      this.setState({\n        selectedOptionId: id,\n        inputValue: option,\n        isShowingOptions: false,\n        announcement: `\"${option}\" selected. List collapsed.`\n      })\n    }\n\n    render() {\n      const {\n        inputValue,\n        isShowingOptions,\n        highlightedOptionId,\n        selectedOptionId,\n        announcement\n      } = this.state\n\n      return (\n        <div>\n          <Select\n            renderLabel=\"Single Select\"\n            assistiveText=\"Use arrow keys to navigate options.\"\n            inputValue={inputValue}\n            isShowingOptions={isShowingOptions}\n            onBlur={this.handleBlur}\n            onRequestShowOptions={this.handleShowOptions}\n            onRequestHideOptions={this.handleHideOptions}\n            onRequestHighlightOption={this.handleHighlightOption}\n            onRequestSelectOption={this.handleSelectOption}\n          >\n            {this.props.options.map((option) => {\n              return (\n                <Select.Option\n                  id={option.id}\n                  key={option.id}\n                  isHighlighted={option.id === highlightedOptionId}\n                  isSelected={option.id === selectedOptionId}\n                >\n                  {option.label}\n                </Select.Option>\n              )\n            })}\n          </Select>\n          <Alert\n            liveRegion={() => document.getElementById('flash-messages')}\n            liveRegionPoliteness=\"assertive\"\n            screenReaderOnly\n          >\n            {announcement}\n          </Alert>\n        </div>\n      )\n    }\n  }\n\n  render(\n    <View>\n      <SingleSelectExample\n        options={[\n          { id: 'opt1', label: 'Alaska' },\n          { id: 'opt2', label: 'American Samoa' },\n          { id: 'opt3', label: 'Arizona' },\n          { id: 'opt4', label: 'Arkansas' },\n          { id: 'opt5', label: 'California' },\n          { id: 'opt6', label: 'Colorado' },\n          { id: 'opt7', label: 'Connecticut' },\n          { id: 'opt8', label: 'Delaware' },\n          { id: 'opt9', label: 'District Of Columbia' },\n          { id: 'opt10', label: 'Federated States Of Micronesia' },\n          { id: 'opt11', label: 'Florida' },\n          { id: 'opt12', label: 'Georgia (unavailable)' },\n          { id: 'opt13', label: 'Guam' },\n          { id: 'opt14', label: 'Hawaii' },\n          { id: 'opt15', label: 'Idaho' },\n          { id: 'opt16', label: 'Illinois' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n- ```js\n  const SingleSelectExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState(options[0].label)\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(options[0].id)\n    const [announcement, setAnnouncement] = useState(null)\n\n    const getOptionById = (queryId) => {\n      return options.find(({ id }) => id === queryId)\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n    }\n\n    const handleHideOptions = (event) => {\n      const option = getOptionById(selectedOptionId).label\n      setIsShowingOptions(false)\n      setHighlightedOptionId(null)\n      setSelectedOptionId(selectedOptionId ? option : '')\n      setAnnouncement('List collapsed.')\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const optionsAvailable = `${options.length} options available.`\n      const nowOpen = !isShowingOptions\n        ? `List expanded. ${optionsAvailable}`\n        : ''\n      const option = getOptionById(id).label\n      setHighlightedOptionId(id)\n      setInputValue(event.type === 'keydown' ? option : inputValue)\n      setAnnouncement(`${option} ${nowOpen}`)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id).label\n      setSelectedOptionId(id)\n      setInputValue(option)\n      setIsShowingOptions(false)\n      setAnnouncement(`\"${option}\" selected. List collapsed.`)\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Single Select\"\n          assistiveText=\"Use arrow keys to navigate options.\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n        >\n          {options.map((option) => {\n            return (\n              <Select.Option\n                id={option.id}\n                key={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n              >\n                {option.label}\n              </Select.Option>\n            )\n          })}\n        </Select>\n        <Alert\n          liveRegion={() => document.getElementById('flash-messages')}\n          liveRegionPoliteness=\"assertive\"\n          screenReaderOnly\n        >\n          {announcement}\n        </Alert>\n      </div>\n    )\n  }\n  render(\n    <View>\n      <SingleSelectExample\n        options={[\n          { id: 'opt1', label: 'Alaska' },\n          { id: 'opt2', label: 'American Samoa' },\n          { id: 'opt3', label: 'Arizona' },\n          { id: 'opt4', label: 'Arkansas' },\n          { id: 'opt5', label: 'California' },\n          { id: 'opt6', label: 'Colorado' },\n          { id: 'opt7', label: 'Connecticut' },\n          { id: 'opt8', label: 'Delaware' },\n          { id: 'opt9', label: 'District Of Columbia' },\n          { id: 'opt10', label: 'Federated States Of Micronesia' },\n          { id: 'opt11', label: 'Florida' },\n          { id: 'opt12', label: 'Georgia (unavailable)' },\n          { id: 'opt13', label: 'Guam' },\n          { id: 'opt14', label: 'Hawaii' },\n          { id: 'opt15', label: 'Idaho' },\n          { id: 'opt16', label: 'Illinois' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n#### Providing autocomplete behavior\n\nIt's best practice to always provide autocomplete functionality to help users make a selection. The example below demonstrates one method of filtering options based on user input, but this logic should be customized to what works best for the application.\n\n> Note: Select makes some conditional assumptions about keyboard behavior. For example, if the list is NOT showing, up/down arrow keys and the space key, will show the list. Otherwise, the arrows will navigate options and the space key will type a space character.\n\n- ```javascript\n  class AutocompleteExample extends React.Component {\n    state = {\n      inputValue: '',\n      isShowingOptions: false,\n      highlightedOptionId: null,\n      selectedOptionId: null,\n      filteredOptions: this.props.options,\n      announcement: null\n    }\n\n    getOptionById(queryId) {\n      return this.props.options.find(({ id }) => id === queryId)\n    }\n\n    getOptionsChangedMessage(newOptions) {\n      let message =\n        newOptions.length !== this.state.filteredOptions.length\n          ? `${newOptions.length} options available.` // options changed, announce new total\n          : null // options haven't changed, don't announce\n      if (message && newOptions.length > 0) {\n        // options still available\n        if (this.state.highlightedOptionId !== newOptions[0].id) {\n          // highlighted option hasn't been announced\n          const option = this.getOptionById(newOptions[0].id).label\n          message = `${option}. ${message}`\n        }\n      }\n      return message\n    }\n\n    filterOptions = (value) => {\n      return this.props.options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    matchValue() {\n      const {\n        filteredOptions,\n        inputValue,\n        highlightedOptionId,\n        selectedOptionId\n      } = this.state\n\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          return {\n            inputValue: onlyOption.label,\n            selectedOptionId: onlyOption.id,\n            filteredOptions: this.filterOptions('')\n          }\n        }\n      }\n      // allow user to return to empty input and no selection\n      if (inputValue.length === 0) {\n        return { selectedOptionId: null }\n      }\n      // no match found, return selected option label to input\n      if (selectedOptionId) {\n        const selectedOption = this.getOptionById(selectedOptionId)\n        return { inputValue: selectedOption.label }\n      }\n      // input value is from highlighted option, not user input\n      // clear input, reset options\n      if (highlightedOptionId) {\n        if (inputValue === this.getOptionById(highlightedOptionId).label) {\n          return {\n            inputValue: '',\n            filteredOptions: this.filterOptions('')\n          }\n        }\n      }\n    }\n\n    handleShowOptions = (event) => {\n      this.setState(({ filteredOptions }) => ({\n        isShowingOptions: true,\n        announcement: `List expanded. ${filteredOptions.length} options available.`\n      }))\n    }\n\n    handleHideOptions = (event) => {\n      const { selectedOptionId, inputValue } = this.state\n      this.setState({\n        isShowingOptions: false,\n        highlightedOptionId: null,\n        announcement: 'List collapsed.',\n        ...this.matchValue()\n      })\n    }\n\n    handleBlur = (event) => {\n      this.setState({ highlightedOptionId: null })\n    }\n\n    handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = this.getOptionById(id)\n      if (!option) return // prevent highlighting of empty option\n      this.setState((state) => ({\n        highlightedOptionId: id,\n        inputValue: event.type === 'keydown' ? option.label : state.inputValue,\n        announcement: option.label\n      }))\n    }\n\n    handleSelectOption = (event, { id }) => {\n      const option = this.getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      this.setState({\n        selectedOptionId: id,\n        inputValue: option.label,\n        isShowingOptions: false,\n        filteredOptions: this.props.options,\n        announcement: `${option.label} selected. List collapsed.`\n      })\n    }\n\n    handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = this.filterOptions(value)\n      this.setState((state) => ({\n        inputValue: value,\n        filteredOptions: newOptions,\n        highlightedOptionId: newOptions.length > 0 ? newOptions[0].id : null,\n        isShowingOptions: true,\n        selectedOptionId: value === '' ? null : state.selectedOptionId,\n        announcement: this.getOptionsChangedMessage(newOptions)\n      }))\n    }\n\n    render() {\n      const {\n        inputValue,\n        isShowingOptions,\n        highlightedOptionId,\n        selectedOptionId,\n        filteredOptions,\n        announcement\n      } = this.state\n\n      return (\n        <div>\n          <Select\n            renderLabel=\"Autocomplete\"\n            assistiveText=\"Type or use arrow keys to navigate options.\"\n            placeholder=\"Start typing to search...\"\n            inputValue={inputValue}\n            isShowingOptions={isShowingOptions}\n            onBlur={this.handleBlur}\n            onInputChange={this.handleInputChange}\n            onRequestShowOptions={this.handleShowOptions}\n            onRequestHideOptions={this.handleHideOptions}\n            onRequestHighlightOption={this.handleHighlightOption}\n            onRequestSelectOption={this.handleSelectOption}\n            renderBeforeInput={<IconUserSolid inline={false} />}\n            renderAfterInput={<IconSearchLine inline={false} />}\n          >\n            {filteredOptions.length > 0 ? (\n              filteredOptions.map((option) => {\n                return (\n                  <Select.Option\n                    id={option.id}\n                    key={option.id}\n                    isHighlighted={option.id === highlightedOptionId}\n                    isSelected={option.id === selectedOptionId}\n                    isDisabled={option.disabled}\n                    renderBeforeLabel={\n                      !option.disabled ? IconUserSolid : IconUserLine\n                    }\n                  >\n                    {!option.disabled\n                      ? option.label\n                      : `${option.label} (unavailable)`}\n                  </Select.Option>\n                )\n              })\n            ) : (\n              <Select.Option id=\"empty-option\" key=\"empty-option\">\n                ---\n              </Select.Option>\n            )}\n          </Select>\n          <Alert\n            liveRegion={() => document.getElementById('flash-messages')}\n            liveRegionPoliteness=\"assertive\"\n            screenReaderOnly\n          >\n            {announcement}\n          </Alert>\n        </div>\n      )\n    }\n  }\n\n  render(\n    <View>\n      <AutocompleteExample\n        options={[\n          { id: 'opt0', label: 'Aaron Aaronson' },\n          { id: 'opt1', label: 'Amber Murphy' },\n          { id: 'opt2', label: 'Andrew Miller' },\n          { id: 'opt3', label: 'Barbara Ward' },\n          { id: 'opt4', label: 'Byron Cranston', disabled: true },\n          { id: 'opt5', label: 'Dennis Reynolds' },\n          { id: 'opt6', label: 'Dee Reynolds' },\n          { id: 'opt7', label: 'Ezra Betterthan' },\n          { id: 'opt8', label: 'Jeff Spicoli' },\n          { id: 'opt9', label: 'Joseph Smith' },\n          { id: 'opt10', label: 'Jasmine Diaz' },\n          { id: 'opt11', label: 'Martin Harris' },\n          { id: 'opt12', label: 'Michael Morgan', disabled: true },\n          { id: 'opt13', label: 'Michelle Rodriguez' },\n          { id: 'opt14', label: 'Ziggy Stardust' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n- ```js\n  const AutocompleteExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState('')\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(null)\n    const [filteredOptions, setFilteredOptions] = useState(options)\n    const [announcement, setAnnouncement] = useState(null)\n\n    const getOptionById = (queryId) => {\n      return options.find(({ id }) => id === queryId)\n    }\n\n    const getOptionsChangedMessage = (newOptions) => {\n      let message =\n        newOptions.length !== filteredOptions.length\n          ? `${newOptions.length} options available.` // options changed, announce new total\n          : null // options haven't changed, don't announce\n      if (message && newOptions.length > 0) {\n        // options still available\n        if (highlightedOptionId !== newOptions[0].id) {\n          // highlighted option hasn't been announced\n          const option = getOptionById(newOptions[0].id).label\n          message = `${option}. ${message}`\n        }\n      }\n      return message\n    }\n\n    const filterOptions = (value) => {\n      return options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    const matchValue = () => {\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          setInputValue(onlyOption.label)\n          setSelectedOptionId(onlyOption.id)\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n      // allow user to return to empty input and no selection\n      else if (inputValue.length === 0) {\n        setSelectedOptionId(null)\n      }\n      // no match found, return selected option label to input\n      else if (selectedOptionId) {\n        const selectedOption = getOptionById(selectedOptionId)\n        setInputValue(selectedOption.label)\n      }\n      // input value is from highlighted option, not user input\n      // clear input, reset options\n      else if (highlightedOptionId) {\n        if (inputValue === getOptionById(highlightedOptionId).label) {\n          setInputValue('')\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n      setAnnouncement(\n        `List expanded. ${filteredOptions.length} options available.`\n      )\n    }\n\n    const handleHideOptions = (event) => {\n      setIsShowingOptions(false)\n      setHighlightedOptionId(false)\n      setAnnouncement('List collapsed.')\n      matchValue()\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = getOptionById(id)\n      if (!option) return // prevent highlighting of empty option\n      setHighlightedOptionId(id)\n      setInputValue(event.type === 'keydown' ? option.label : inputValue)\n      setAnnouncement(option.label)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      setSelectedOptionId(id)\n      setInputValue(option.label)\n      setIsShowingOptions(false)\n      setFilteredOptions(options)\n      setAnnouncement(`${option.label} selected. List collapsed.`)\n    }\n\n    const handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = filterOptions(value)\n      setInputValue(value)\n      setFilteredOptions(newOptions)\n      setHighlightedOptionId(newOptions.length > 0 ? newOptions[0].id : null)\n      setIsShowingOptions(true)\n      setSelectedOptionId(value === '' ? null : selectedOptionId)\n      setAnnouncement(getOptionsChangedMessage(newOptions))\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Autocomplete\"\n          assistiveText=\"Type or use arrow keys to navigate options.\"\n          placeholder=\"Start typing to search...\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onInputChange={handleInputChange}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n          renderBeforeInput={<IconUserSolid inline={false} />}\n          renderAfterInput={<IconSearchLine inline={false} />}\n        >\n          {filteredOptions.length > 0 ? (\n            filteredOptions.map((option) => {\n              return (\n                <Select.Option\n                  id={option.id}\n                  key={option.id}\n                  isHighlighted={option.id === highlightedOptionId}\n                  isSelected={option.id === selectedOptionId}\n                  isDisabled={option.disabled}\n                  renderBeforeLabel={\n                    !option.disabled ? IconUserSolid : IconUserLine\n                  }\n                >\n                  {!option.disabled\n                    ? option.label\n                    : `${option.label} (unavailable)`}\n                </Select.Option>\n              )\n            })\n          ) : (\n            <Select.Option id=\"empty-option\" key=\"empty-option\">\n              ---\n            </Select.Option>\n          )}\n        </Select>\n        <Alert\n          liveRegion={() => document.getElementById('flash-messages')}\n          liveRegionPoliteness=\"assertive\"\n          screenReaderOnly\n        >\n          {announcement}\n        </Alert>\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <AutocompleteExample\n        options={[\n          { id: 'opt0', label: 'Aaron Aaronson' },\n          { id: 'opt1', label: 'Amber Murphy' },\n          { id: 'opt2', label: 'Andrew Miller' },\n          { id: 'opt3', label: 'Barbara Ward' },\n          { id: 'opt4', label: 'Byron Cranston', disabled: true },\n          { id: 'opt5', label: 'Dennis Reynolds' },\n          { id: 'opt6', label: 'Dee Reynolds' },\n          { id: 'opt7', label: 'Ezra Betterthan' },\n          { id: 'opt8', label: 'Jeff Spicoli' },\n          { id: 'opt9', label: 'Joseph Smith' },\n          { id: 'opt10', label: 'Jasmine Diaz' },\n          { id: 'opt11', label: 'Martin Harris' },\n          { id: 'opt12', label: 'Michael Morgan', disabled: true },\n          { id: 'opt13', label: 'Michelle Rodriguez' },\n          { id: 'opt14', label: 'Ziggy Stardust' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n#### Highlighting and selecting options\n\nTo mark an option as \"highlighted\", use the option's `isHighlighted` prop. Note that only one highlighted option is permitted. Similarly, use `isSelected` to mark an option or multiple options as \"selected\". When allowing multiple selections, it's best to render a [Tag](#Tag) with [AccessibleContent](#AccessibleContent) for each selected option via the `renderBeforeInput` prop.\n\n- ```javascript\n  class MultipleSelectExample extends React.Component {\n    state = {\n      inputValue: '',\n      isShowingOptions: false,\n      highlightedOptionId: null,\n      selectedOptionId: ['opt1', 'opt6'],\n      filteredOptions: this.props.options,\n      announcement: null\n    }\n\n    getOptionById(queryId) {\n      return this.props.options.find(({ id }) => id === queryId)\n    }\n\n    getOptionsChangedMessage(newOptions) {\n      let message =\n        newOptions.length !== this.state.filteredOptions.length\n          ? `${newOptions.length} options available.` // options changed, announce new total\n          : null // options haven't changed, don't announce\n      if (message && newOptions.length > 0) {\n        // options still available\n        if (this.state.highlightedOptionId !== newOptions[0].id) {\n          // highlighted option hasn't been announced\n          const option = this.getOptionById(newOptions[0].id).label\n          message = `${option}. ${message}`\n        }\n      }\n      return message\n    }\n\n    filterOptions = (value) => {\n      return this.props.options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    matchValue() {\n      const {\n        filteredOptions,\n        inputValue,\n        highlightedOptionId,\n        selectedOptionId\n      } = this.state\n\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          return {\n            inputValue: '',\n            selectedOptionId: [...selectedOptionId, onlyOption.id],\n            filteredOptions: this.filterOptions('')\n          }\n        }\n      }\n      // input value is from highlighted option, not user input\n      // clear input, reset options\n      if (highlightedOptionId) {\n        if (inputValue === this.getOptionById(highlightedOptionId).label) {\n          return {\n            inputValue: '',\n            filteredOptions: this.filterOptions('')\n          }\n        }\n      }\n    }\n\n    handleShowOptions = (event) => {\n      this.setState({ isShowingOptions: true })\n    }\n\n    handleHideOptions = (event) => {\n      this.setState({\n        isShowingOptions: false,\n        ...this.matchValue()\n      })\n    }\n\n    handleBlur = (event) => {\n      this.setState({\n        highlightedOptionId: null\n      })\n    }\n\n    handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = this.getOptionById(id)\n      if (!option) return // prevent highlighting empty option\n      this.setState((state) => ({\n        highlightedOptionId: id,\n        inputValue: event.type === 'keydown' ? option.label : state.inputValue,\n        announcement: option.label\n      }))\n    }\n\n    handleSelectOption = (event, { id }) => {\n      const option = this.getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      this.setState((state) => ({\n        selectedOptionId: [...state.selectedOptionId, id],\n        highlightedOptionId: null,\n        filteredOptions: this.filterOptions(''),\n        inputValue: '',\n        isShowingOptions: false,\n        announcement: `${option.label} selected. List collapsed.`\n      }))\n    }\n\n    handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = this.filterOptions(value)\n      this.setState({\n        inputValue: value,\n        filteredOptions: newOptions,\n        highlightedOptionId: newOptions.length > 0 ? newOptions[0].id : null,\n        isShowingOptions: true,\n        announcement: this.getOptionsChangedMessage(newOptions)\n      })\n    }\n\n    handleKeyDown = (event) => {\n      const { selectedOptionId, inputValue } = this.state\n      if (event.keyCode === 8) {\n        // when backspace key is pressed\n        if (inputValue === '' && selectedOptionId.length > 0) {\n          // remove last selected option, if input has no entered text\n          this.setState((state) => ({\n            highlightedOptionId: null,\n            selectedOptionId: state.selectedOptionId.slice(0, -1)\n          }))\n        }\n      }\n    }\n    // remove a selected option tag\n    dismissTag(e, tag) {\n      // prevent closing of list\n      e.stopPropagation()\n      e.preventDefault()\n\n      const newSelection = this.state.selectedOptionId.filter(\n        (id) => id !== tag\n      )\n      this.setState(\n        {\n          selectedOptionId: newSelection,\n          highlightedOptionId: null,\n          announcement: `${this.getOptionById(tag).label} removed`\n        },\n        () => {\n          this.inputRef.focus()\n        }\n      )\n    }\n    // render tags when multiple options are selected\n    renderTags() {\n      const { selectedOptionId } = this.state\n      return selectedOptionId.map((id, index) => (\n        <Tag\n          dismissible\n          key={id}\n          text={\n            <AccessibleContent alt={`Remove ${this.getOptionById(id).label}`}>\n              {this.getOptionById(id).label}\n            </AccessibleContent>\n          }\n          margin={index > 0 ? 'xxx-small 0 xxx-small xx-small' : 'xxx-small 0'}\n          onClick={(e) => this.dismissTag(e, id)}\n        />\n      ))\n    }\n\n    render() {\n      const {\n        inputValue,\n        isShowingOptions,\n        highlightedOptionId,\n        selectedOptionId,\n        filteredOptions,\n        announcement\n      } = this.state\n\n      return (\n        <div>\n          <Select\n            renderLabel=\"Multiple Select\"\n            assistiveText=\"Type or use arrow keys to navigate options. Multiple selections allowed.\"\n            inputValue={inputValue}\n            isShowingOptions={isShowingOptions}\n            inputRef={(el) => (this.inputRef = el)}\n            onBlur={this.handleBlur}\n            onInputChange={this.handleInputChange}\n            onRequestShowOptions={this.handleShowOptions}\n            onRequestHideOptions={this.handleHideOptions}\n            onRequestHighlightOption={this.handleHighlightOption}\n            onRequestSelectOption={this.handleSelectOption}\n            onKeyDown={this.handleKeyDown}\n            renderBeforeInput={\n              selectedOptionId.length > 0 ? this.renderTags() : null\n            }\n          >\n            {filteredOptions.length > 0 ? (\n              filteredOptions.map((option, index) => {\n                if (selectedOptionId.indexOf(option.id) === -1) {\n                  return (\n                    <Select.Option\n                      id={option.id}\n                      key={option.id}\n                      isHighlighted={option.id === highlightedOptionId}\n                    >\n                      {option.label}\n                    </Select.Option>\n                  )\n                }\n              })\n            ) : (\n              <Select.Option id=\"empty-option\" key=\"empty-option\">\n                ---\n              </Select.Option>\n            )}\n          </Select>\n          <Alert\n            liveRegion={() => document.getElementById('flash-messages')}\n            liveRegionPoliteness=\"assertive\"\n            screenReaderOnly\n          >\n            {announcement}\n          </Alert>\n        </div>\n      )\n    }\n  }\n\n  render(\n    <View>\n      <MultipleSelectExample\n        options={[\n          { id: 'opt1', label: 'Alaska' },\n          { id: 'opt2', label: 'American Samoa' },\n          { id: 'opt3', label: 'Arizona' },\n          { id: 'opt4', label: 'Arkansas' },\n          { id: 'opt5', label: 'California' },\n          { id: 'opt6', label: 'Colorado' },\n          { id: 'opt7', label: 'Connecticut' },\n          { id: 'opt8', label: 'Delaware' },\n          { id: 'opt9', label: 'District Of Columbia' },\n          { id: 'opt10', label: 'Federated States Of Micronesia' },\n          { id: 'opt11', label: 'Florida' },\n          { id: 'opt12', label: 'Georgia (unavailable)' },\n          { id: 'opt13', label: 'Guam' },\n          { id: 'opt14', label: 'Hawaii' },\n          { id: 'opt15', label: 'Idaho' },\n          { id: 'opt16', label: 'Illinois' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n- ```js\n  const MultipleSelectExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState('')\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(['opt1', 'opt6'])\n    const [filteredOptions, setFilteredOptions] = useState(options)\n    const [announcement, setAnnouncement] = useState(null)\n    const inputRef = useRef(null)\n\n    const getOptionById = (queryId) => {\n      return options.find(({ id }) => id === queryId)\n    }\n\n    const getOptionsChangedMessage = (newOptions) => {\n      let message =\n        newOptions.length !== filteredOptions.length\n          ? `${newOptions.length} options available.` // options changed, announce new total\n          : null // options haven't changed, don't announce\n      if (message && newOptions.length > 0) {\n        // options still available\n        if (highlightedOptionId !== newOptions[0].id) {\n          // highlighted option hasn't been announced\n          const option = getOptionById(newOptions[0].id).label\n          message = `${option}. ${message}`\n        }\n      }\n      return message\n    }\n\n    const filterOptions = (value) => {\n      return options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    const matchValue = () => {\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          setInputValue('')\n          setSelectedOptionId([...selectedOptionId, onlyOption.id])\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n      // input value is from highlighted option, not user input\n      // clear input, reset options\n      else if (highlightedOptionId) {\n        if (inputValue === getOptionById(highlightedOptionId).label) {\n          setInputValue('')\n          setFilteredOptions(filterOptions(''))\n        }\n      }\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n    }\n\n    const handleHideOptions = (event) => {\n      setIsShowingOptions(false)\n      matchValue()\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = getOptionById(id)\n      if (!option) return // prevent highlighting empty option\n      setHighlightedOptionId(id)\n      setInputValue(event.type === 'keydown' ? option.label : inputValue)\n      setAnnouncement(option.label)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      setSelectedOptionId([...selectedOptionId, id])\n      setHighlightedOptionId(null)\n      setFilteredOptions(filterOptions(''))\n      setInputValue('')\n      setIsShowingOptions(false)\n      setAnnouncement(`${option.label} selected. List collapsed.`)\n    }\n\n    const handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = filterOptions(value)\n      setInputValue(value)\n      setFilteredOptions(newOptions)\n      sethHighlightedOptionId(newOptions.length > 0 ? newOptions[0].id : null)\n      setIsShowingOptions(true)\n      setAnnouncement(getOptionsChangedMessage(newOptions))\n    }\n\n    const handleKeyDown = (event) => {\n      if (event.keyCode === 8) {\n        // when backspace key is pressed\n        if (inputValue === '' && selectedOptionId.length > 0) {\n          // remove last selected option, if input has no entered text\n          setHighlightedOptionId(null)\n          setSelectedOptionId(selectedOptionId.slice(0, -1))\n        }\n      }\n    }\n\n    // remove a selected option tag\n    const dismissTag = (e, tag) => {\n      // prevent closing of list\n      e.stopPropagation()\n      e.preventDefault()\n\n      const newSelection = selectedOptionId.filter((id) => id !== tag)\n\n      setSelectedOptionId(newSelection)\n      setHighlightedOptionId(null)\n      setAnnouncement(`${getOptionById(tag).label} removed`)\n\n      inputRef.current.focus()\n    }\n\n    const renderTags = () => {\n      return selectedOptionId.map((id, index) => (\n        <Tag\n          dismissible\n          key={id}\n          text={\n            <AccessibleContent alt={`Remove ${this.getOptionById(id).label}`}>\n              {this.getOptionById(id).label}\n            </AccessibleContent>\n          }\n          margin={index > 0 ? 'xxx-small 0 xxx-small xx-small' : 'xxx-small 0'}\n          onClick={(e) => dismissTag(e, id)}\n        />\n      ))\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Multiple Select\"\n          assistiveText=\"Type or use arrow keys to navigate options. Multiple selections allowed.\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          inputRef={(el) => (inputRef.current = el)}\n          onBlur={handleBlur}\n          onInputChange={handleInputChange}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n          onKeyDown={handleKeyDown}\n          renderBeforeInput={selectedOptionId.length > 0 ? renderTags() : null}\n        >\n          {filteredOptions.length > 0 ? (\n            filteredOptions.map((option, index) => {\n              if (selectedOptionId.indexOf(option.id) === -1) {\n                return (\n                  <Select.Option\n                    id={option.id}\n                    key={option.id}\n                    isHighlighted={option.id === highlightedOptionId}\n                  >\n                    {option.label}\n                  </Select.Option>\n                )\n              }\n            })\n          ) : (\n            <Select.Option id=\"empty-option\" key=\"empty-option\">\n              ---\n            </Select.Option>\n          )}\n        </Select>\n        <Alert\n          liveRegion={() => document.getElementById('flash-messages')}\n          liveRegionPoliteness=\"assertive\"\n          screenReaderOnly\n        >\n          {announcement}\n        </Alert>\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <MultipleSelectExample\n        options={[\n          { id: 'opt1', label: 'Alaska' },\n          { id: 'opt2', label: 'American Samoa' },\n          { id: 'opt3', label: 'Arizona' },\n          { id: 'opt4', label: 'Arkansas' },\n          { id: 'opt5', label: 'California' },\n          { id: 'opt6', label: 'Colorado' },\n          { id: 'opt7', label: 'Connecticut' },\n          { id: 'opt8', label: 'Delaware' },\n          { id: 'opt9', label: 'District Of Columbia' },\n          { id: 'opt10', label: 'Federated States Of Micronesia' },\n          { id: 'opt11', label: 'Florida' },\n          { id: 'opt12', label: 'Georgia (unavailable)' },\n          { id: 'opt13', label: 'Guam' },\n          { id: 'opt14', label: 'Hawaii' },\n          { id: 'opt15', label: 'Idaho' },\n          { id: 'opt16', label: 'Illinois' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n#### Composing option groups\n\nIn addition to `<Select.Option />` Select also accepts `<Select.Group />` as children. This is meant to serve the same purpose as `<optgroup>` elements. Group only requires you provide a label via its `renderLabel` prop. Groups and their associated options also accept icons or other stylistic additions if needed.\n\n- ```javascript\n  class GroupSelectExample extends React.Component {\n    state = {\n      inputValue: this.props.options['Western'][0].label,\n      isShowingOptions: false,\n      highlightedOptionId: null,\n      selectedOptionId: this.props.options['Western'][0].id,\n      announcement: null\n    }\n\n    getOptionById(id) {\n      const { options } = this.props\n      let match = null\n      Object.keys(options).forEach((key, index) => {\n        for (let i = 0; i < options[key].length; i++) {\n          const option = options[key][i]\n          if (id === option.id) {\n            // return group property with the object just to make it easier\n            // to check which group the option belongs to\n            match = { ...option, group: key }\n            break\n          }\n        }\n      })\n      return match\n    }\n\n    getGroupChangedMessage(newOption) {\n      const currentOption = this.getOptionById(this.state.highlightedOptionId)\n      const isNewGroup =\n        !currentOption || currentOption.group !== newOption.group\n      let message = isNewGroup ? `Group ${newOption.group} entered. ` : ''\n      message += newOption.label\n      return message\n    }\n\n    handleShowOptions = (event) => {\n      this.setState({\n        isShowingOptions: true,\n        highlightedOptionId: null\n      })\n    }\n\n    handleHideOptions = (event) => {\n      const { selectedOptionId } = this.state\n      this.setState({\n        isShowingOptions: false,\n        highlightedOptionId: null,\n        inputValue: this.getOptionById(selectedOptionId).label\n      })\n    }\n\n    handleBlur = (event) => {\n      this.setState({\n        highlightedOptionId: null\n      })\n    }\n\n    handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const newOption = this.getOptionById(id)\n      this.setState((state) => ({\n        highlightedOptionId: id,\n        inputValue:\n          event.type === 'keydown' ? newOption.label : state.inputValue,\n        announcement: this.getGroupChangedMessage(newOption)\n      }))\n    }\n\n    handleSelectOption = (event, { id }) => {\n      this.setState({\n        selectedOptionId: id,\n        inputValue: this.getOptionById(id).label,\n        isShowingOptions: false,\n        announcement: `${this.getOptionById(id).label} selected.`\n      })\n    }\n\n    renderLabel(text, variant) {\n      return (\n        <span>\n          <Badge\n            type=\"notification\"\n            variant={variant}\n            standalone\n            margin=\"0 x-small xxx-small 0\"\n          />\n          {text}\n        </span>\n      )\n    }\n\n    renderGroup() {\n      const { options } = this.props\n      const { highlightedOptionId, selectedOptionId } = this.state\n\n      return Object.keys(options).map((key, index) => {\n        const badgeVariant = key === 'Eastern' ? 'success' : 'primary'\n        return (\n          <Select.Group\n            key={index}\n            renderLabel={this.renderLabel(key, badgeVariant)}\n          >\n            {options[key].map((option) => (\n              <Select.Option\n                key={option.id}\n                id={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n              >\n                {option.label}\n              </Select.Option>\n            ))}\n          </Select.Group>\n        )\n      })\n    }\n\n    render() {\n      const {\n        inputValue,\n        isShowingOptions,\n        highlightedOptionId,\n        selectedOptionId,\n        filteredOptions,\n        announcement\n      } = this.state\n\n      return (\n        <div>\n          <Select\n            renderLabel=\"Group Select\"\n            assistiveText=\"Type or use arrow keys to navigate options.\"\n            inputValue={inputValue}\n            isShowingOptions={isShowingOptions}\n            onBlur={this.handleBlur}\n            onRequestShowOptions={this.handleShowOptions}\n            onRequestHideOptions={this.handleHideOptions}\n            onRequestHighlightOption={this.handleHighlightOption}\n            onRequestSelectOption={this.handleSelectOption}\n            renderBeforeInput={\n              <Badge\n                type=\"notification\"\n                variant={\n                  this.getOptionById(selectedOptionId).group === 'Eastern'\n                    ? 'success'\n                    : 'primary'\n                }\n                standalone\n                margin=\"0 0 xxx-small 0\"\n              />\n            }\n          >\n            {this.renderGroup()}\n          </Select>\n          <Alert\n            liveRegion={() => document.getElementById('flash-messages')}\n            liveRegionPoliteness=\"assertive\"\n            screenReaderOnly\n          >\n            {announcement}\n          </Alert>\n        </div>\n      )\n    }\n  }\n\n  render(\n    <View>\n      <GroupSelectExample\n        options={{\n          Western: [\n            { id: 'opt5', label: 'Alaska' },\n            { id: 'opt6', label: 'California' },\n            { id: 'opt7', label: 'Colorado' },\n            { id: 'opt8', label: 'Idaho' }\n          ],\n          Eastern: [\n            { id: 'opt1', label: 'Alabama' },\n            { id: 'opt2', label: 'Connecticut' },\n            { id: 'opt3', label: 'Delaware' },\n            { id: '4', label: 'Illinois' }\n          ]\n        }}\n      />\n    </View>\n  )\n  ```\n\n- ```js\n  const GroupSelectExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState(options['Western'][0].label)\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(\n      options['Western'][0].id\n    )\n    const [announcement, setAnnouncement] = useState(null)\n\n    const getOptionById = (id) => {\n      let match = null\n      Object.keys(options).forEach((key, index) => {\n        for (let i = 0; i < options[key].length; i++) {\n          const option = options[key][i]\n          if (id === option.id) {\n            // return group property with the object just to make it easier\n            // to check which group the option belongs to\n            match = { ...option, group: key }\n            break\n          }\n        }\n      })\n      return match\n    }\n\n    const getGroupChangedMessage = (newOption) => {\n      const currentOption = getOptionById(highlightedOptionId)\n      const isNewGroup =\n        !currentOption || currentOption.group !== newOption.group\n      let message = isNewGroup ? `Group ${newOption.group} entered. ` : ''\n      message += newOption.label\n      return message\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n      setHighlightedOptionId(null)\n    }\n\n    const handleHideOptions = (event) => {\n      setIsShowingOptions(false)\n      setHighlightedOptionId(null)\n      setInputValue(getOptionById(selectedOptionId).label)\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const newOption = getOptionById(id)\n      setHighlightedOptionId(id)\n      setInputValue(event.type === 'keydown' ? newOption.label : inputValue)\n      setAnnouncement(getGroupChangedMessage(newOption))\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      setSelectedOptionId(id)\n      setInputValue(getOptionById(id).label)\n      setIsShowingOptions(false)\n      setAnnouncement(`${getOptionById(id).label} selected.`)\n    }\n\n    const renderLabel = (text, variant) => {\n      return (\n        <span>\n          <Badge\n            type=\"notification\"\n            variant={variant}\n            standalone\n            margin=\"0 x-small xxx-small 0\"\n          />\n          {text}\n        </span>\n      )\n    }\n\n    const renderGroup = () => {\n      return Object.keys(options).map((key, index) => {\n        const badgeVariant = key === 'Eastern' ? 'success' : 'primary'\n        return (\n          <Select.Group\n            key={index}\n            renderLabel={renderLabel(key, badgeVariant)}\n          >\n            {options[key].map((option) => (\n              <Select.Option\n                key={option.id}\n                id={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n              >\n                {option.label}\n              </Select.Option>\n            ))}\n          </Select.Group>\n        )\n      })\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Group Select\"\n          assistiveText=\"Type or use arrow keys to navigate options.\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n          renderBeforeInput={\n            <Badge\n              type=\"notification\"\n              variant={\n                getOptionById(selectedOptionId).group === 'Eastern'\n                  ? 'success'\n                  : 'primary'\n              }\n              standalone\n              margin=\"0 0 xxx-small 0\"\n            />\n          }\n        >\n          {renderGroup()}\n        </Select>\n        <Alert\n          liveRegion={() => document.getElementById('flash-messages')}\n          liveRegionPoliteness=\"assertive\"\n          screenReaderOnly\n        >\n          {announcement}\n        </Alert>\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <GroupSelectExample\n        options={{\n          Western: [\n            { id: 'opt5', label: 'Alaska' },\n            { id: 'opt6', label: 'California' },\n            { id: 'opt7', label: 'Colorado' },\n            { id: 'opt8', label: 'Idaho' }\n          ],\n          Eastern: [\n            { id: 'opt1', label: 'Alabama' },\n            { id: 'opt2', label: 'Connecticut' },\n            { id: 'opt3', label: 'Delaware' },\n            { id: '4', label: 'Illinois' }\n          ]\n        }}\n      />\n    </View>\n  )\n  ```\n\n##### Using groups with autocomplete on Safari\n\nDue to a WebKit bug if you are using `Select.Group` with autocomplete, the screenreader won't announce highlight/selection changes. This only seems to be an issue in Safari. Here is an example how you can work around that:\n\n- ```javascript\n  class GroupSelectAutocompleteExample extends React.Component {\n    state = {\n      inputValue: '',\n      isShowingOptions: false,\n      highlightedOptionId: null,\n      selectedOptionId: null,\n      filteredOptions: this.props.options,\n      announcement: null\n    }\n\n    getOptionById(id) {\n      const options = this.props.options\n      return Object.values(options)\n        .flat()\n        .find((o) => o?.id === id)\n    }\n\n    filterOptions(value, options) {\n      const filteredOptions = {}\n      Object.keys(options).forEach((key) => {\n        filteredOptions[key] = options[key]?.filter((option) =>\n          option.label.toLowerCase().includes(value.toLowerCase())\n        )\n      })\n      const optionsWithoutEmptyKeys = Object.keys(filteredOptions)\n        .filter((k) => filteredOptions[k].length > 0)\n        .reduce((a, k) => ({ ...a, [k]: filteredOptions[k] }), {})\n      return optionsWithoutEmptyKeys\n    }\n\n    handleShowOptions = (event) => {\n      this.setState({\n        isShowingOptions: true,\n        highlightedOptionId: null\n      })\n    }\n\n    handleHideOptions = (event) => {\n      const { selectedOptionId } = this.state\n      this.setState({\n        isShowingOptions: false,\n        highlightedOptionId: null\n      })\n    }\n\n    handleBlur = (event) => {\n      this.setState({\n        highlightedOptionId: null\n      })\n    }\n\n    handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = this.getOptionById(id)\n      setTimeout(() => {\n        this.setState((state) => ({\n          announcement: option.label\n        }))\n      }, 0)\n      this.setState((state) => ({\n        highlightedOptionId: id\n      }))\n    }\n\n    handleSelectOption = (event, { id }) => {\n      const option = this.getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      this.setState({\n        selectedOptionId: id,\n        inputValue: option.label,\n        isShowingOptions: false,\n        filteredOptions: this.props.options,\n        announcement: option.label\n      })\n    }\n\n    handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = this.filterOptions(value, this.props.options)\n      this.setState((state) => ({\n        inputValue: value,\n        filteredOptions: newOptions,\n        highlightedOptionId: newOptions.length > 0 ? newOptions[0].id : null,\n        isShowingOptions: true,\n        selectedOptionId: value === '' ? null : state.selectedOptionId\n      }))\n    }\n\n    renderGroup() {\n      const filteredOptions = this.state.filteredOptions\n      const { highlightedOptionId, selectedOptionId } = this.state\n\n      return Object.keys(filteredOptions).map((key, index) => {\n        return (\n          <Select.Group key={index} renderLabel={key}>\n            {filteredOptions[key].map((option) => (\n              <Select.Option\n                key={option.id}\n                id={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n              >\n                {option.label}\n              </Select.Option>\n            ))}\n          </Select.Group>\n        )\n      })\n    }\n\n    renderScreenReaderHelper() {\n      const announcement = this.state.announcement\n      return (\n        window.safari && (\n          <ScreenReaderContent>\n            <span role=\"alert\" aria-live=\"assertive\">\n              {announcement}\n            </span>\n          </ScreenReaderContent>\n        )\n      )\n    }\n\n    render() {\n      const {\n        inputValue,\n        isShowingOptions,\n        highlightedOptionId,\n        selectedOptionId,\n        filteredOptions\n      } = this.state\n\n      return (\n        <div>\n          <Select\n            placeholder=\"Start typing to search...\"\n            renderLabel=\"Group Select with autocomplete\"\n            assistiveText=\"Type or use arrow keys to navigate options.\"\n            inputValue={inputValue}\n            isShowingOptions={isShowingOptions}\n            onBlur={this.handleBlur}\n            onInputChange={this.handleInputChange}\n            onRequestShowOptions={this.handleShowOptions}\n            onRequestHideOptions={this.handleHideOptions}\n            onRequestHighlightOption={this.handleHighlightOption}\n            onRequestSelectOption={this.handleSelectOption}\n          >\n            {this.renderGroup()}\n          </Select>\n          {this.renderScreenReaderHelper()}\n        </div>\n      )\n    }\n  }\n\n  render(\n    <View>\n      <GroupSelectAutocompleteExample\n        options={{\n          Western: [\n            { id: 'opt5', label: 'Alaska' },\n            { id: 'opt6', label: 'California' },\n            { id: 'opt7', label: 'Colorado' },\n            { id: 'opt8', label: 'Idaho' }\n          ],\n          Eastern: [\n            { id: 'opt1', label: 'Alabama' },\n            { id: 'opt2', label: 'Connecticut' },\n            { id: 'opt3', label: 'Delaware' },\n            { id: '4', label: 'Illinois' }\n          ]\n        }}\n      />\n    </View>\n  )\n  ```\n\n- ```js\n  const GroupSelectAutocompleteExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState('')\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(null)\n    const [filteredOptions, setFilteredOptions] = useState(options)\n    const [announcement, setAnnouncement] = useState(null)\n\n    const getOptionById = (id) => {\n      return Object.values(options)\n        .flat()\n        .find((o) => o?.id === id)\n    }\n\n    const filterOptions = (value, options) => {\n      const filteredOptions = {}\n      Object.keys(options).forEach((key) => {\n        filteredOptions[key] = options[key]?.filter((option) =>\n          option.label.toLowerCase().includes(value.toLowerCase())\n        )\n      })\n      const optionsWithoutEmptyKeys = Object.keys(filteredOptions)\n        .filter((k) => filteredOptions[k].length > 0)\n        .reduce((a, k) => ({ ...a, [k]: filteredOptions[k] }), {})\n      return optionsWithoutEmptyKeys\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n      setHighlightedOptionId(null)\n    }\n\n    const handleHideOptions = (event) => {\n      setIsShowingOptions(false)\n      setHighlightedOptionId(null)\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = getOptionById(id)\n      setTimeout(() => {\n        setAnnouncement(option.label)\n      }, 0)\n      setHighlightedOptionId(id)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      setSelectedOptionId(id)\n      setInputValue(option.label)\n      setIsShowingOptions(false)\n      setFilteredOptions(options)\n      setAnnouncement(option.label)\n    }\n\n    const handleInputChange = (event) => {\n      const value = event.target.value\n      const newOptions = filterOptions(value, options)\n      setInputValue(value)\n      setFilteredOptions(newOptions)\n      setHighlightedOptionId(newOptions.length > 0 ? newOptions[0].id : null)\n      setIsShowingOptions(true)\n      setSelectedOptionId(value === '' ? null : selectedOptionId)\n    }\n\n    const renderGroup = () => {\n      return Object.keys(filteredOptions).map((key, index) => {\n        return (\n          <Select.Group key={index} renderLabel={key}>\n            {filteredOptions[key].map((option) => (\n              <Select.Option\n                key={option.id}\n                id={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n              >\n                {option.label}\n              </Select.Option>\n            ))}\n          </Select.Group>\n        )\n      })\n    }\n\n    const renderScreenReaderHelper = () => {\n      return (\n        window.safari && (\n          <ScreenReaderContent>\n            <span role=\"alert\" aria-live=\"assertive\">\n              {announcement}\n            </span>\n          </ScreenReaderContent>\n        )\n      )\n    }\n\n    return (\n      <div>\n        <Select\n          placeholder=\"Start typing to search...\"\n          renderLabel=\"Group Select with autocomplete\"\n          assistiveText=\"Type or use arrow keys to navigate options.\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onInputChange={handleInputChange}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n        >\n          {renderGroup()}\n        </Select>\n        {renderScreenReaderHelper()}\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <GroupSelectAutocompleteExample\n        options={{\n          Western: [\n            { id: 'opt5', label: 'Alaska' },\n            { id: 'opt6', label: 'California' },\n            { id: 'opt7', label: 'Colorado' },\n            { id: 'opt8', label: 'Idaho' }\n          ],\n          Eastern: [\n            { id: 'opt1', label: 'Alabama' },\n            { id: 'opt2', label: 'Connecticut' },\n            { id: 'opt3', label: 'Delaware' },\n            { id: '4', label: 'Illinois' }\n          ]\n        }}\n      />\n    </View>\n  )\n  ```\n\n#### Asynchronous option loading\n\nIf no results match the user's search, it's recommended to leave `isShowingOptions` as `true` and to display an \"empty option\" as a way of communicating that there are no matches. Similarly, it's helpful to display a [Spinner](#Spinner) in an empty option while options load.\n\n- ```javascript\n  class AsyncExample extends React.Component {\n    state = {\n      inputValue: '',\n      isShowingOptions: false,\n      isLoading: false,\n      highlightedOptionId: null,\n      selectedOptionId: null,\n      selectedOptionLabel: '',\n      filteredOptions: [],\n      announcement: null\n    }\n\n    timeoutId = null\n\n    getOptionById(queryId) {\n      return this.state.filteredOptions.find(({ id }) => id === queryId)\n    }\n\n    filterOptions = (value) => {\n      return this.props.options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    matchValue() {\n      const {\n        filteredOptions,\n        inputValue,\n        selectedOptionId,\n        selectedOptionLabel\n      } = this.state\n\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          return {\n            inputValue: onlyOption.label,\n            selectedOptionId: onlyOption.id\n          }\n        }\n      }\n      // allow user to return to empty input and no selection\n      if (inputValue.length === 0) {\n        return { selectedOptionId: null, filteredOptions: [] }\n      }\n      // no match found, return selected option label to input\n      if (selectedOptionId) {\n        return { inputValue: selectedOptionLabel }\n      }\n    }\n\n    handleShowOptions = (event) => {\n      this.setState(({ filteredOptions }) => ({\n        isShowingOptions: true\n      }))\n    }\n\n    handleHideOptions = (event) => {\n      const { selectedOptionId, inputValue } = this.state\n      this.setState({\n        isShowingOptions: false,\n        highlightedOptionId: null,\n        announcement: 'List collapsed.',\n        ...this.matchValue()\n      })\n    }\n\n    handleBlur = (event) => {\n      this.setState({ highlightedOptionId: null })\n    }\n\n    handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = this.getOptionById(id)\n      if (!option) return // prevent highlighting of empty option\n      this.setState((state) => ({\n        highlightedOptionId: id,\n        inputValue: event.type === 'keydown' ? option.label : state.inputValue,\n        announcement: option.label\n      }))\n    }\n\n    handleSelectOption = (event, { id }) => {\n      const option = this.getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      this.setState({\n        selectedOptionId: id,\n        selectedOptionLabel: option.label,\n        inputValue: option.label,\n        isShowingOptions: false,\n        announcement: `${option.label} selected. List collapsed.`,\n        filteredOptions: [this.getOptionById(id)]\n      })\n    }\n\n    handleInputChange = (event) => {\n      const value = event.target.value\n      clearTimeout(this.timeoutId)\n\n      if (!value || value === '') {\n        this.setState({\n          isLoading: false,\n          inputValue: value,\n          isShowingOptions: true,\n          selectedOptionId: null,\n          selectedOptionLabel: null,\n          filteredOptions: []\n        })\n      } else {\n        this.setState({\n          isLoading: true,\n          inputValue: value,\n          isShowingOptions: true,\n          filteredOptions: [],\n          highlightedOptionId: null,\n          announcement: 'Loading options.'\n        })\n\n        this.timeoutId = setTimeout(() => {\n          const newOptions = this.filterOptions(value)\n          this.setState({\n            filteredOptions: newOptions,\n            isLoading: false,\n            announcement: `${newOptions.length} options available.`\n          })\n        }, 1500)\n      }\n    }\n\n    render() {\n      const {\n        inputValue,\n        isShowingOptions,\n        isLoading,\n        highlightedOptionId,\n        selectedOptionId,\n        filteredOptions,\n        announcement\n      } = this.state\n\n      return (\n        <div>\n          <Select\n            renderLabel=\"Async Select\"\n            assistiveText=\"Type to search\"\n            inputValue={inputValue}\n            isShowingOptions={isShowingOptions}\n            onBlur={this.handleBlur}\n            onInputChange={this.handleInputChange}\n            onRequestShowOptions={this.handleShowOptions}\n            onRequestHideOptions={this.handleHideOptions}\n            onRequestHighlightOption={this.handleHighlightOption}\n            onRequestSelectOption={this.handleSelectOption}\n          >\n            {filteredOptions.length > 0 ? (\n              filteredOptions.map((option) => {\n                return (\n                  <Select.Option\n                    id={option.id}\n                    key={option.id}\n                    isHighlighted={option.id === highlightedOptionId}\n                    isSelected={option.id === selectedOptionId}\n                    isDisabled={option.disabled}\n                    renderBeforeLabel={\n                      !option.disabled ? IconUserSolid : IconUserLine\n                    }\n                  >\n                    {option.label}\n                  </Select.Option>\n                )\n              })\n            ) : (\n              <Select.Option id=\"empty-option\" key=\"empty-option\">\n                {isLoading ? (\n                  <Spinner renderTitle=\"Loading\" size=\"x-small\" />\n                ) : inputValue !== '' ? (\n                  'No results'\n                ) : (\n                  'Type to search'\n                )}\n              </Select.Option>\n            )}\n          </Select>\n          <Alert\n            liveRegion={() => document.getElementById('flash-messages')}\n            liveRegionPoliteness=\"assertive\"\n            screenReaderOnly\n          >\n            {announcement}\n          </Alert>\n        </div>\n      )\n    }\n  }\n\n  render(\n    <View>\n      <AsyncExample\n        options={[\n          { id: 'opt0', label: 'Aaron Aaronson' },\n          { id: 'opt1', label: 'Amber Murphy' },\n          { id: 'opt2', label: 'Andrew Miller' },\n          { id: 'opt3', label: 'Barbara Ward' },\n          { id: 'opt4', label: 'Byron Cranston', disabled: true },\n          { id: 'opt5', label: 'Dennis Reynolds' },\n          { id: 'opt6', label: 'Dee Reynolds' },\n          { id: 'opt7', label: 'Ezra Betterthan' },\n          { id: 'opt8', label: 'Jeff Spicoli' },\n          { id: 'opt9', label: 'Joseph Smith' },\n          { id: 'opt10', label: 'Jasmine Diaz' },\n          { id: 'opt11', label: 'Martin Harris' },\n          { id: 'opt12', label: 'Michael Morgan', disabled: true },\n          { id: 'opt13', label: 'Michelle Rodriguez' },\n          { id: 'opt14', label: 'Ziggy Stardust' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n- ```js\n  const AsyncExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState('')\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [isLoading, setIsLoading] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(null)\n    const [selectedOptionLabel, setSelectedOptionLabel] = useState('')\n    const [filteredOptions, setFilteredOptions] = useState([])\n    const [announcement, setAnnouncement] = useState(null)\n\n    let timeoutId = null\n\n    const getOptionById = (queryId) => {\n      return filteredOptions.find(({ id }) => id === queryId)\n    }\n\n    const filterOptions = (value) => {\n      return options.filter((option) =>\n        option.label.toLowerCase().startsWith(value.toLowerCase())\n      )\n    }\n\n    const matchValue = () => {\n      // an option matching user input exists\n      if (filteredOptions.length === 1) {\n        const onlyOption = filteredOptions[0]\n        // automatically select the matching option\n        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n          setInputValue(onlyOption.label)\n          setSelectedOptionId(onlyOption.id)\n          return\n        }\n      }\n      // allow user to return to empty input and no selection\n      if (inputValue.length === 0) {\n        setSelectedOptionId(null)\n        setFilteredOptions([])\n        return\n      }\n      // no match found, return selected option label to input\n      if (selectedOptionId) {\n        setInputValue(selectedOptionLabel)\n        return\n      }\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n    }\n\n    const handleHideOptions = (event) => {\n      setIsShowingOptions(false)\n      setHighlightedOptionId(null)\n      setAnnouncement('List collapsed.')\n      matchValue()\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const option = getOptionById(id)\n      if (!option) return // prevent highlighting of empty option\n\n      setHighlightedOptionId(id)\n      setInputValue(event.type === 'keydown' ? option.label : inputValue)\n      setAnnouncement(option.label)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id)\n      if (!option) return // prevent selecting of empty option\n      setSelectedOptionId(id)\n      setSelectedOptionLabel(option.label)\n      setInputValue(option.label)\n      setIsShowingOptions(false)\n      setAnnouncement(`${option.label} selected. List collapsed.`)\n      setFilteredOptions([getOptionById(id)])\n    }\n\n    const handleInputChange = (event) => {\n      const value = event.target.value\n      clearTimeout(timeoutId)\n\n      if (!value || value === '') {\n        setIsLoading(false)\n        setInputValue(value)\n        setIsShowingOptions(true)\n        setSelectedOptionId(null)\n        setSelectedOptionLabel(null)\n        setFilteredOptions([])\n      } else {\n        setIsLoading(true)\n        setInputValue(value)\n        setIsShowingOptions(true)\n        setFilteredOptions([])\n        setHighlightedOptionId(null)\n        setAnnouncement('Loading options.')\n\n        timeoutId = setTimeout(() => {\n          const newOptions = filterOptions(value)\n          setFilteredOptions(newOptions)\n          setIsLoading(false)\n          setAnnouncement(`${newOptions.length} options available.`)\n        }, 1500)\n      }\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Async Select\"\n          assistiveText=\"Type to search\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onInputChange={handleInputChange}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n        >\n          {filteredOptions.length > 0 ? (\n            filteredOptions.map((option) => {\n              return (\n                <Select.Option\n                  id={option.id}\n                  key={option.id}\n                  isHighlighted={option.id === highlightedOptionId}\n                  isSelected={option.id === selectedOptionId}\n                  isDisabled={option.disabled}\n                  renderBeforeLabel={\n                    !option.disabled ? IconUserSolid : IconUserLine\n                  }\n                >\n                  {option.label}\n                </Select.Option>\n              )\n            })\n          ) : (\n            <Select.Option id=\"empty-option\" key=\"empty-option\">\n              {isLoading ? (\n                <Spinner renderTitle=\"Loading\" size=\"x-small\" />\n              ) : inputValue !== '' ? (\n                'No results'\n              ) : (\n                'Type to search'\n              )}\n            </Select.Option>\n          )}\n        </Select>\n        <Alert\n          liveRegion={() => document.getElementById('flash-messages')}\n          liveRegionPoliteness=\"assertive\"\n          screenReaderOnly\n        >\n          {announcement}\n        </Alert>\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <AsyncExample\n        options={[\n          { id: 'opt0', label: 'Aaron Aaronson' },\n          { id: 'opt1', label: 'Amber Murphy' },\n          { id: 'opt2', label: 'Andrew Miller' },\n          { id: 'opt3', label: 'Barbara Ward' },\n          { id: 'opt4', label: 'Byron Cranston', disabled: true },\n          { id: 'opt5', label: 'Dennis Reynolds' },\n          { id: 'opt6', label: 'Dee Reynolds' },\n          { id: 'opt7', label: 'Ezra Betterthan' },\n          { id: 'opt8', label: 'Jeff Spicoli' },\n          { id: 'opt9', label: 'Joseph Smith' },\n          { id: 'opt10', label: 'Jasmine Diaz' },\n          { id: 'opt11', label: 'Martin Harris' },\n          { id: 'opt12', label: 'Michael Morgan', disabled: true },\n          { id: 'opt13', label: 'Michelle Rodriguez' },\n          { id: 'opt14', label: 'Ziggy Stardust' }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n### Icons\n\nTo display icons (or other elements) before or after an option, pass it via the `renderBeforeLabel` and `renderAfterLabel` prop to `Select.Option`. You can pass a function as well, which will have a `props` parameter, so you can access the properties of that `Select.Option` (e.g. if it is currently `isHighlighted`). The available props are: `[ id, isDisabled, isSelected, isHighlighted, children ]`.\n\n- ```js\n  class SingleSelectExample extends React.Component {\n    state = {\n      inputValue: this.props.options[0].label,\n      isShowingOptions: false,\n      highlightedOptionId: null,\n      selectedOptionId: this.props.options[0].id,\n      announcement: null\n    }\n\n    getOptionById(queryId) {\n      return this.props.options.find(({ id }) => id === queryId)\n    }\n\n    handleShowOptions = (event) => {\n      this.setState({\n        isShowingOptions: true\n      })\n    }\n\n    handleHideOptions = (event) => {\n      const { selectedOptionId } = this.state\n      const option = this.getOptionById(selectedOptionId).label\n      this.setState({\n        isShowingOptions: false,\n        highlightedOptionId: null,\n        inputValue: selectedOptionId ? option : '',\n        announcement: 'List collapsed.'\n      })\n    }\n\n    handleBlur = (event) => {\n      this.setState({\n        highlightedOptionId: null\n      })\n    }\n\n    handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const optionsAvailable = `${this.props.options.length} options available.`\n      const nowOpen = !this.state.isShowingOptions\n        ? `List expanded. ${optionsAvailable}`\n        : ''\n      const option = this.getOptionById(id).label\n      this.setState((state) => ({\n        highlightedOptionId: id,\n        inputValue: event.type === 'keydown' ? option : state.inputValue,\n        announcement: `${option} ${nowOpen}`\n      }))\n    }\n\n    handleSelectOption = (event, { id }) => {\n      const option = this.getOptionById(id).label\n      this.setState({\n        selectedOptionId: id,\n        inputValue: option,\n        isShowingOptions: false,\n        announcement: `\"${option}\" selected. List collapsed.`\n      })\n    }\n\n    render() {\n      const {\n        inputValue,\n        isShowingOptions,\n        highlightedOptionId,\n        selectedOptionId,\n        announcement\n      } = this.state\n\n      return (\n        <div>\n          <Select\n            renderLabel=\"Option Icons\"\n            assistiveText=\"Use arrow keys to navigate options.\"\n            inputValue={inputValue}\n            isShowingOptions={isShowingOptions}\n            onBlur={this.handleBlur}\n            onRequestShowOptions={this.handleShowOptions}\n            onRequestHideOptions={this.handleHideOptions}\n            onRequestHighlightOption={this.handleHighlightOption}\n            onRequestSelectOption={this.handleSelectOption}\n          >\n            {this.props.options.map((option) => {\n              return (\n                <Select.Option\n                  id={option.id}\n                  key={option.id}\n                  isHighlighted={option.id === highlightedOptionId}\n                  isSelected={option.id === selectedOptionId}\n                  renderBeforeLabel={option.renderBeforeLabel}\n                >\n                  {option.label}\n                </Select.Option>\n              )\n            })}\n          </Select>\n          <Alert\n            liveRegion={() => document.getElementById('flash-messages')}\n            liveRegionPoliteness=\"assertive\"\n            screenReaderOnly\n          >\n            {announcement}\n          </Alert>\n        </div>\n      )\n    }\n  }\n\n  render(\n    <View>\n      <SingleSelectExample\n        options={[\n          {\n            id: 'opt1',\n            label: 'Text',\n            renderBeforeLabel: 'XY'\n          },\n          {\n            id: 'opt2',\n            label: 'Icon',\n            renderBeforeLabel: <IconCheckSolid />\n          },\n          {\n            id: 'opt3',\n            label: 'Colored Icon',\n            renderBeforeLabel: (props) => {\n              let color = 'brand'\n              if (props.isHighlighted) color = 'primary-inverse'\n              if (props.isSelected) color = 'primary'\n              if (props.isDisabled) color = 'warning'\n              return <IconInstructureSolid color={color} />\n            }\n          }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n- ```js\n  const SingleSelectExample = ({ options }) => {\n    const [inputValue, setInputValue] = useState(options[0].label)\n    const [isShowingOptions, setIsShowingOptions] = useState(false)\n    const [highlightedOptionId, setHighlightedOptionId] = useState(null)\n    const [selectedOptionId, setSelectedOptionId] = useState(options[0].id)\n    const [announcement, setAnnouncement] = useState(null)\n\n    const getOptionById = (queryId) => {\n      return options.find(({ id }) => id === queryId)\n    }\n\n    const handleShowOptions = (event) => {\n      setIsShowingOptions(true)\n    }\n\n    const handleHideOptions = (event) => {\n      const option = getOptionById(selectedOptionId).label\n      setIsShowingOptions(false)\n      setHighlightedOptionId(null)\n      setInputValue(selectedOptionId ? option : '')\n      setAnnouncement('List collapsed.')\n    }\n\n    const handleBlur = (event) => {\n      setHighlightedOptionId(null)\n    }\n\n    const handleHighlightOption = (event, { id }) => {\n      event.persist()\n      const optionsAvailable = `${options.length} options available.`\n      const nowOpen = !isShowingOptions\n        ? `List expanded. ${optionsAvailable}`\n        : ''\n      const option = getOptionById(id).label\n      setHighlightedOptionId(id)\n      setInputValue(event.type === 'keydown' ? option : inputValue)\n      setAnnouncement(`${option} ${nowOpen}`)\n    }\n\n    const handleSelectOption = (event, { id }) => {\n      const option = getOptionById(id).label\n      setSelectedOptionId(id)\n      setInputValue(option)\n      setIsShowingOptions(false)\n      setAnnouncement(`\"${option}\" selected. List collapsed.`)\n    }\n\n    return (\n      <div>\n        <Select\n          renderLabel=\"Option Icons\"\n          assistiveText=\"Use arrow keys to navigate options.\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={handleBlur}\n          onRequestShowOptions={handleShowOptions}\n          onRequestHideOptions={handleHideOptions}\n          onRequestHighlightOption={handleHighlightOption}\n          onRequestSelectOption={handleSelectOption}\n        >\n          {options.map((option) => {\n            return (\n              <Select.Option\n                id={option.id}\n                key={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n                renderBeforeLabel={option.renderBeforeLabel}\n              >\n                {option.label}\n              </Select.Option>\n            )\n          })}\n        </Select>\n        <Alert\n          liveRegion={() => document.getElementById('flash-messages')}\n          liveRegionPoliteness=\"assertive\"\n          screenReaderOnly\n        >\n          {announcement}\n        </Alert>\n      </div>\n    )\n  }\n\n  render(\n    <View>\n      <SingleSelectExample\n        options={[\n          {\n            id: 'opt1',\n            label: 'Text',\n            renderBeforeLabel: 'XY'\n          },\n          {\n            id: 'opt2',\n            label: 'Icon',\n            renderBeforeLabel: <IconCheckSolid />\n          },\n          {\n            id: 'opt3',\n            label: 'Colored Icon',\n            renderBeforeLabel: (props) => {\n              let color = 'brand'\n              if (props.isHighlighted) color = 'primary-inverse'\n              if (props.isSelected) color = 'primary'\n              if (props.isDisabled) color = 'warning'\n              return <IconInstructureSolid color={color} />\n            }\n          }\n        ]}\n      />\n    </View>\n  )\n  ```\n\n#### Providing assistive text for screen readers\n\nIt's important to ensure screen reader users receive instruction and feedback while interacting with a `Select`, but screen reader support for the `combobox` role varies. The `assistiveText` prop should always be used to explain how a keyboard user can make a selection. Additionally, a live region should be updated with feedback as the component is interacted with, such as when options are filtered or highlighted. Using an [Alert](#Alert) with the `screenReaderOnly` prop is the easiest way to do this.\n\n> Note: This component uses a native `input` field to render the selected value. When it's included in a native HTML `form`, the text value will be sent to the backend instead of anything specified in the `value` field of the `Select.Option`-s. We do not recommend to use this component this way, rather write your own code that collects information and sends it to the backend.\n","displayName":"Select","methods":[],"props":{"renderLabel":{"type":{"name":"union","value":[{"name":"node"},{"name":"func"}]},"required":true,"description":"The form field label.","tsType":{"name":"union","raw":"| keyof ReactHTML\n| keyof ReactSVG\n| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ReactHTML"},{"name":"ReactSVG"},{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}]}},"inputValue":{"type":{"name":"string"},"required":false,"description":"The value to display in the text input.","tsType":{"name":"string"},"defaultValue":{"value":"''","computed":false}},"id":{"type":{"name":"string"},"required":false,"description":"The id of the text input. One is generated if not supplied.","tsType":{"name":"string"}},"size":{"type":{"name":"enum","value":[{"value":"'small'","computed":false},{"value":"'medium'","computed":false},{"value":"'large'","computed":false}]},"required":false,"description":"The size of the text input.","tsType":{"name":"union","raw":"'small' | 'medium' | 'large'","elements":[{"name":"literal","value":"'small'"},{"name":"literal","value":"'medium'"},{"name":"literal","value":"'large'"}]},"defaultValue":{"value":"'medium'","computed":false}},"assistiveText":{"type":{"name":"string"},"required":false,"description":"Additional helpful text to provide to screen readers about the operation\nof the component.","tsType":{"name":"string"}},"placeholder":{"type":{"name":"string"},"required":false,"description":"Html placeholder text to display when the input has no value. This should\nbe hint text, not a label replacement.","tsType":{"name":"string"}},"interaction":{"type":{"name":"enum","value":[{"value":"'enabled'","computed":false},{"value":"'disabled'","computed":false},{"value":"'readonly'","computed":false}]},"required":false,"description":"Specifies if interaction with the input is enabled, disabled, or readonly.\nWhen \"disabled\", the input changes visibly to indicate that it cannot\nreceive user interactions. When \"readonly\" the input still cannot receive\nuser interactions but it keeps the same styles as if it were enabled.","tsType":{"name":"union","raw":"'enabled' | 'disabled' | 'readonly'","elements":[{"name":"literal","value":"'enabled'"},{"name":"literal","value":"'disabled'"},{"name":"literal","value":"'readonly'"}]},"defaultValue":{"value":"undefined","computed":true}},"isRequired":{"type":{"name":"bool"},"required":false,"description":"Whether or not the text input is required.","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"isInline":{"type":{"name":"bool"},"required":false,"description":"Whether the input is rendered inline with other elements or if it\nis rendered as a block level element.","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"width":{"type":{"name":"string"},"required":false,"description":"The width of the text input.","tsType":{"name":"string"}},"htmlSize":{"type":{"name":"number"},"required":false,"description":"The width of the input (integer value 0 or higher), if a width is not explicitly\nprovided via the `width` prop.\n\nOnly applicable if `isInline={true}`.\n\nFor more see https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/size","tsType":{"name":"number"}},"visibleOptionsCount":{"type":{"name":"number"},"required":false,"description":"The number of options that should be visible before having to scroll. Works best when the options are the same height.","tsType":{"name":"number"},"defaultValue":{"value":"8","computed":false}},"optionsMaxHeight":{"type":{"name":"string"},"required":false,"description":"The max height the options list can be before having to scroll. If\nset, it will __override__ the `visibleOptionsCount` prop.","tsType":{"name":"string"}},"optionsMaxWidth":{"type":{"name":"string"},"required":false,"description":"The max width the options list can be before option text wraps. If not\nset, the list will only display as wide as the text input.","tsType":{"name":"string"}},"messages":{"type":{"name":"arrayOf","value":{"name":"custom","raw":"FormPropTypes.message"}},"required":false,"description":"Displays messages and validation for the input. It should be an object\nwith the following shape:\n`{\n  text: React.ReactNode,\n  type: One of: ['newError', 'error', 'hint', 'success', 'screenreader-only']\n}`","tsType":{"name":"Array","elements":[{"name":"FormMessage"}],"raw":"FormMessage[]"}},"placement":{"type":{"name":"custom","raw":"PositionPropTypes.placement"},"required":false,"description":"The placement of the options list.","tsType":{"name":"PlacementPropValues"},"defaultValue":{"value":"'bottom stretch'","computed":false}},"constrain":{"type":{"name":"custom","raw":"PositionPropTypes.constrain"},"required":false,"description":"The parent in which to constrain the placement.","tsType":{"name":"PositionConstraint"},"defaultValue":{"value":"'window'","computed":false}},"mountNode":{"type":{"name":"custom","raw":"PositionPropTypes.mountNode"},"required":false,"description":"An element or a function returning an element to use mount the options\nlist to in the DOM (defaults to `document.body`)","tsType":{"name":"PositionMountNode"}},"onFocus":{"type":{"name":"func"},"required":false,"description":"Callback fired when text input receives focus.","tsType":{"name":"signature","type":"function","raw":"(event: React.FocusEvent<HTMLInputElement>) => void","signature":{"arguments":[{"type":{"name":"ReactFocusEvent","raw":"React.FocusEvent<HTMLInputElement>","elements":[{"name":"HTMLInputElement"}]},"name":"event"}],"return":{"name":"void"}}}},"onBlur":{"type":{"name":"func"},"required":false,"description":"Callback fired when text input loses focus.","tsType":{"name":"signature","type":"function","raw":"(event: React.FocusEvent<HTMLInputElement>) => void","signature":{"arguments":[{"type":{"name":"ReactFocusEvent","raw":"React.FocusEvent<HTMLInputElement>","elements":[{"name":"HTMLInputElement"}]},"name":"event"}],"return":{"name":"void"}}}},"onInputChange":{"type":{"name":"func"},"required":false,"description":"Callback fired when text input value changes.","tsType":{"name":"signature","type":"function","raw":"(\n  event: React.ChangeEvent<HTMLInputElement>,\n  value: string\n) => void","signature":{"arguments":[{"type":{"name":"ReactChangeEvent","raw":"React.ChangeEvent<HTMLInputElement>","elements":[{"name":"HTMLInputElement"}]},"name":"event"},{"type":{"name":"string"},"name":"value"}],"return":{"name":"void"}}}},"isShowingOptions":{"type":{"name":"bool"},"required":false,"description":"Whether or not to show the options list.","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"onRequestShowOptions":{"type":{"name":"func"},"required":false,"description":"Callback fired requesting that the options list be shown.","tsType":{"name":"signature","type":"function","raw":"(event: React.SyntheticEvent) => void","signature":{"arguments":[{"type":{"name":"ReactSyntheticEvent","raw":"React.SyntheticEvent"},"name":"event"}],"return":{"name":"void"}}}},"onRequestHideOptions":{"type":{"name":"func"},"required":false,"description":"Callback fired requesting that the options list be hidden.","tsType":{"name":"signature","type":"function","raw":"(event: React.SyntheticEvent) => void","signature":{"arguments":[{"type":{"name":"ReactSyntheticEvent","raw":"React.SyntheticEvent"},"name":"event"}],"return":{"name":"void"}}}},"onRequestHighlightOption":{"type":{"name":"func"},"required":false,"description":"Callback fired requesting a particular option be highlighted.","tsType":{"name":"signature","type":"function","raw":"(\n  event: React.SyntheticEvent,\n  data: { id?: string; direction?: 1 | -1 }\n) => void","signature":{"arguments":[{"type":{"name":"ReactSyntheticEvent","raw":"React.SyntheticEvent"},"name":"event"},{"type":{"name":"signature","type":"object","raw":"{ id?: string; direction?: 1 | -1 }","signature":{"properties":[{"key":"id","value":{"name":"string","required":false}},{"key":"direction","value":{"name":"union","raw":"1 | -1","elements":[{"name":"literal","value":"1"},{"name":"literal","value":"-1"}],"required":false}}]}},"name":"data"}],"return":{"name":"void"}}}},"onRequestSelectOption":{"type":{"name":"func"},"required":false,"description":"Callback fired requesting a particular option be selected.","tsType":{"name":"signature","type":"function","raw":"(\n  event: React.SyntheticEvent,\n  data: { id?: string }\n) => void","signature":{"arguments":[{"type":{"name":"ReactSyntheticEvent","raw":"React.SyntheticEvent"},"name":"event"},{"type":{"name":"signature","type":"object","raw":"{ id?: string }","signature":{"properties":[{"key":"id","value":{"name":"string","required":false}}]}},"name":"data"}],"return":{"name":"void"}}}},"inputRef":{"type":{"name":"func"},"required":false,"description":"A ref to the html `input` element.","tsType":{"name":"signature","type":"function","raw":"(inputElement: HTMLInputElement | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"HTMLInputElement | null","elements":[{"name":"HTMLInputElement"},{"name":"null"}]},"name":"inputElement"}],"return":{"name":"void"}}}},"listRef":{"type":{"name":"func"},"required":false,"description":"A ref to the html `ul` element.","tsType":{"name":"signature","type":"function","raw":"(listElement: HTMLUListElement | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"HTMLUListElement | null","elements":[{"name":"HTMLUListElement"},{"name":"null"}]},"name":"listElement"}],"return":{"name":"void"}}}},"renderBeforeInput":{"type":{"name":"union","value":[{"name":"node"},{"name":"func"}]},"required":false,"description":"Content to display before the text input. This will commonly be an icon or\ntags to show multiple selections.","tsType":{"name":"union","raw":"| keyof ReactHTML\n| keyof ReactSVG\n| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ReactHTML"},{"name":"ReactSVG"},{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}]}},"renderAfterInput":{"type":{"name":"union","value":[{"name":"node"},{"name":"func"}]},"required":false,"description":"Content to display after the text input. This content will replace the\ndefault arrow icons.","tsType":{"name":"union","raw":"| keyof ReactHTML\n| keyof ReactSVG\n| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ReactHTML"},{"name":"ReactSVG"},{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}]}},"children":{"type":{"name":"custom","raw":"ChildrenPropTypes.oneOf([Group, Option])"},"required":false,"description":"Children of type `<Select.Option />` or `<Select.Group />`.","tsType":{"name":"ReactReactNode","raw":"React.ReactNode"}},"shouldNotWrap":{"type":{"name":"bool"},"required":false,"description":"Prevents the default behavior of wrapping the input and rendered content\nwhen available space is exceeded.","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"scrollToHighlightedOption":{"type":{"name":"bool"},"required":false,"description":"Enable/disable auto scroll to the highlighted option on every re-render","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}},"dir":{"required":false,"tsType":{"name":"union","raw":"'ltr' | 'rtl'","elements":[{"name":"literal","value":"'ltr'"},{"name":"literal","value":"'rtl'"}]},"description":""}},"category":"components","tags":"autocomplete, typeahead, combobox, dropdown, search, form","relativePath":"packages/ui-select/src/Select/index.tsx","extension":".tsx","srcPath":"packages/ui-select/src/Select/index.tsx","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-select/src/Select/index.tsx","packageName":"@instructure/ui-select","requirePath":"@instructure/ui-select/lib/Select/index","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-select/src/Select/index.tsx').default","esPath":"@instructure/ui-select/es/Select/index","themePath":"packages/ui-select/src/Select/theme.ts","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-select/src/Select/theme.ts","id":"Select","title":"Select"}