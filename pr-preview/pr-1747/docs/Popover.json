{"description":"\nPopovers hide or show content as a result of user interaction, such as clicking, hovering, or focusing. When opened, the content remains connected to the element that triggered it. If you only need to display a small amount of text-only content, you might consider using a [Tooltip](#Tooltip). If you need to display a larger amount of content, a [Tray](#Tray) could be a better choice.\n\n#### Uncontrolled Popover\n\n- ```js\n  class Example extends React.Component {\n    state = {\n      withArrow: true,\n      shouldAlignArrow: true,\n      color: 'primary'\n    }\n    toggleWithArrow = (event) =>\n      this.setState({ withArrow: !this.state.withArrow })\n    toggleAlignArrow = (event) =>\n      this.setState({ shouldAlignArrow: !this.state.shouldAlignArrow })\n    changeColor = (event, color) => {\n      this.setState({ color })\n    }\n    render() {\n      return (\n        <>\n          <FormFieldGroup description=\"Uncontrolled Popover Example\">\n            <Checkbox\n              checked={this.state.withArrow}\n              label=\"With Arrow\"\n              onChange={this.toggleWithArrow}\n            />\n            <Checkbox\n              checked={this.state.shouldAlignArrow}\n              label=\"Align Arrow\"\n              onChange={this.toggleAlignArrow}\n            />\n          </FormFieldGroup>\n          <View display=\"block\" margin=\"small none\">\n            <RadioInputGroup\n              name=\"color\"\n              defaultValue=\"primary\"\n              description=\"Color:\"\n              variant=\"toggle\"\n              size=\"small\"\n              onChange={this.changeColor}\n            >\n              <RadioInput label=\"Primary\" value=\"primary\" />\n              <RadioInput label=\"Primary inverse\" value=\"primary-inverse\" />\n            </RadioInputGroup>\n          </View>\n          <View display=\"block\" as=\"div\" margin=\"small\">\n            <Popover\n              renderTrigger={\n                <Link aria-describedby=\"tip\">Hover or focus me</Link>\n              }\n              shouldRenderOffscreen\n              shouldReturnFocus={false}\n              withArrow={this.state.withArrow}\n              shouldAlignArrow={this.state.shouldAlignArrow}\n              color={this.state.color}\n              placement=\"top end\"\n              onPositioned={() => console.log('positioned')}\n              onShowContent={() => console.log('showing')}\n              onHideContent={() => console.log('hidden')}\n            >\n              <View padding=\"x-small\" display=\"block\" as=\"div\" id=\"tip\">\n                Hello World\n              </View>\n            </Popover>\n          </View>\n        </>\n      )\n    }\n  }\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = () => {\n    const [withArrow, setWithArrow] = useState(true)\n    const [shouldAlignArrow, setShouldAlignArrow] = useState(true)\n    const [color, setColor] = useState('primary')\n\n    const toggleWithArrow = () => {\n      setWithArrow((withArrow) => !withArrow)\n    }\n\n    const toggleAlignArrow = () => {\n      setShouldAlignArrow((shouldAlignArrow) => !shouldAlignArrow)\n    }\n\n    const changeColor = (event, color) => {\n      setColor(color)\n    }\n\n    return (\n      <>\n        <FormFieldGroup description=\"Uncontrolled Popover Example\">\n          <Checkbox\n            checked={withArrow}\n            label=\"With Arrow\"\n            onChange={toggleWithArrow}\n          />\n          <Checkbox\n            checked={shouldAlignArrow}\n            label=\"Align Arrow\"\n            onChange={toggleAlignArrow}\n          />\n        </FormFieldGroup>\n        <View display=\"block\" margin=\"small none\">\n          <RadioInputGroup\n            name=\"color\"\n            defaultValue=\"primary\"\n            description=\"Color:\"\n            variant=\"toggle\"\n            size=\"small\"\n            onChange={changeColor}\n          >\n            <RadioInput label=\"Primary\" value=\"primary\" />\n            <RadioInput label=\"Primary inverse\" value=\"primary-inverse\" />\n          </RadioInputGroup>\n        </View>\n        <View display=\"block\" as=\"div\" margin=\"small\">\n          <Popover\n            renderTrigger={\n              <Link aria-describedby=\"tip\">Hover or focus me</Link>\n            }\n            shouldRenderOffscreen\n            shouldReturnFocus={false}\n            withArrow={withArrow}\n            shouldAlignArrow={shouldAlignArrow}\n            color={color}\n            placement=\"top end\"\n            onPositioned={() => console.log('positioned')}\n            onShowContent={() => console.log('showing')}\n            onHideContent={() => console.log('hidden')}\n          >\n            <View padding=\"x-small\" display=\"block\" as=\"div\" id=\"tip\">\n              Hello World\n            </View>\n          </Popover>\n        </View>\n      </>\n    )\n  }\n  render(<Example />)\n  ```\n\n#### Controlled Popover\n\n- ```js\n  class Example extends React.Component {\n    state = {\n      isShowingContent: false\n    }\n\n    renderCloseButton() {\n      return (\n        <CloseButton\n          placement=\"end\"\n          offset=\"small\"\n          onClick={() => this.setState({ isShowingContent: false })}\n          screenReaderLabel=\"Close\"\n        />\n      )\n    }\n\n    render() {\n      return (\n        <View>\n          <Popover\n            renderTrigger={<Button>Sign In</Button>}\n            isShowingContent={this.state.isShowingContent}\n            onShowContent={(e) => {\n              this.setState({ isShowingContent: true })\n            }}\n            onHideContent={(e, { documentClick }) => {\n              this.setState({ isShowingContent: false })\n            }}\n            on=\"click\"\n            screenReaderLabel=\"Popover Dialog Example\"\n            shouldContainFocus\n            shouldReturnFocus\n            shouldCloseOnDocumentClick\n            offsetY=\"16px\"\n          >\n            <View padding=\"medium\" display=\"block\" as=\"form\">\n              {this.renderCloseButton()}\n              <FormFieldGroup description=\"Log In\">\n                <TextInput\n                  renderLabel=\"Username\"\n                  inputRef={(el) => {\n                    if (el) {\n                      this._username = el\n                    }\n                  }}\n                />\n                <TextInput renderLabel=\"Password\" type=\"password\" />\n              </FormFieldGroup>\n            </View>\n          </Popover>\n        </View>\n      )\n    }\n  }\n\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = () => {\n    const [isShowingContent, setIsShowingContent] = useState(false)\n\n    const usernameRef = useRef(null)\n\n    const renderCloseButton = () => (\n      <CloseButton\n        placement=\"end\"\n        offset=\"small\"\n        onClick={() => setIsShowingContent(false)}\n        screenReaderLabel=\"Close\"\n      />\n    )\n\n    return (\n      <View>\n        <Popover\n          renderTrigger={<Button>Sign In</Button>}\n          isShowingContent={isShowingContent}\n          onShowContent={() => {\n            setIsShowingContent(true)\n          }}\n          onHideContent={() => {\n            setIsShowingContent(false)\n          }}\n          on=\"click\"\n          screenReaderLabel=\"Popover Dialog Example\"\n          shouldContainFocus\n          shouldReturnFocus\n          shouldCloseOnDocumentClick\n          offsetY=\"16px\"\n        >\n          <View padding=\"medium\" display=\"block\" as=\"form\">\n            {renderCloseButton()}\n            <FormFieldGroup description=\"Log In\">\n              <TextInput renderLabel=\"Username\" ref={usernameRef} />\n              <TextInput renderLabel=\"Password\" type=\"password\" />\n            </FormFieldGroup>\n          </View>\n        </Popover>\n      </View>\n    )\n  }\n\n  render(<Example />)\n  ```\n\n> Note: Popover can act as a dialog with a close button. With the `shouldContainFocus` property set, it will trap focus inside the Popover.\n\nThe `shouldAlignArrow` prop will offset the popover content to adjust for the offset of the arrow. This will override offsetX for start/end placements, and will override offsetY for top/bottom placements.\n\n- ```js\n  class Example extends React.Component {\n    state = {\n      shouldAlignArrow: true\n    }\n    toggleAlignArrow = (event) =>\n      this.setState({ shouldAlignArrow: !this.state.shouldAlignArrow })\n\n    render() {\n      return (\n        <>\n          <FormFieldGroup description=\"Align Arrow Example\">\n            <Checkbox\n              checked={this.state.shouldAlignArrow}\n              label=\"Align Arrow\"\n              onChange={this.toggleAlignArrow}\n            />\n          </FormFieldGroup>\n          <div\n            style={{\n              paddingBottom: 25,\n              display: 'flex',\n              justifyContent: 'center'\n            }}\n          >\n            <Popover\n              renderTrigger={\n                <div\n                  style={{\n                    display: 'inline-block',\n                    height: '3px',\n                    width: '3px',\n                    background: 'blue'\n                  }}\n                />\n              }\n              isShowingContent={true}\n              placement=\"end top\"\n              shouldAlignArrow={this.state.shouldAlignArrow}\n            >\n              <Heading>\n                Small\n                <br />\n                Target\n              </Heading>\n            </Popover>\n          </div>\n        </>\n      )\n    }\n  }\n\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = () => {\n    const [shouldAlignArrow, setShouldAlignArrow] = useState(true)\n\n    const toggleAlignArrow = () => {\n      setShouldAlignArrow((shouldAlignArrow) => !shouldAlignArrow)\n    }\n\n    return (\n      <>\n        <FormFieldGroup description=\"Align Arrow Example\">\n          <Checkbox\n            checked={shouldAlignArrow}\n            label=\"Align Arrow\"\n            onChange={toggleAlignArrow}\n          />\n        </FormFieldGroup>\n        <div\n          style={{\n            paddingBottom: 25,\n            display: 'flex',\n            justifyContent: 'center'\n          }}\n        >\n          <Popover\n            renderTrigger={\n              <div\n                style={{\n                  display: 'inline-block',\n                  height: '3px',\n                  width: '3px',\n                  background: 'blue'\n                }}\n              />\n            }\n            isShowingContent={true}\n            placement=\"end top\"\n            shouldAlignArrow={shouldAlignArrow}\n          >\n            <Heading>\n              Small\n              <br />\n              Target\n            </Heading>\n          </Popover>\n        </div>\n      </>\n    )\n  }\n\n  render(<Example />)\n  ```\n\nIf the `Popover` contains focusable content and should be rendered in the focus order immediately after the trigger, it can be configured using the `shouldFocusContentOnTriggerBlur` prop. Note that the content must be rendered in the correct order in the document (using the `mountNode` prop).\n\n- ```js\n  class Example extends React.Component {\n    state = {\n      isShowingContent: false\n    }\n\n    render() {\n      return (\n        <div\n          style={{\n            paddingBottom: 50,\n            display: 'flex',\n            justifyContent: 'center'\n          }}\n        >\n          <Popover\n            renderTrigger={<Button margin=\"small\">Focus Me</Button>}\n            isShowingContent={this.state.isShowingContent}\n            onShowContent={(e) => {\n              this.setState({ isShowingContent: true })\n            }}\n            onHideContent={(e) => {\n              this.setState({ isShowingContent: false })\n            }}\n            on={['hover', 'focus']}\n            shouldContainFocus={false}\n            shouldFocusContentOnTriggerBlur={false}\n          >\n            <Button margin=\"small\">Focus Me When Trigger Blurs</Button>\n          </Popover>\n          <div id=\"container\" />\n          <Button id=\"next\" margin=\"small\">\n            Focus Me Next\n          </Button>\n        </div>\n      )\n    }\n  }\n\n  render(<Example />)\n  ```\n\n- ```js\n  const Example = () => {\n    const [isShowingContent, setIsShowingContent] = useState(false)\n\n    return (\n      <div\n        style={{ paddingBottom: 50, display: 'flex', justifyContent: 'center' }}\n      >\n        <Popover\n          renderTrigger={<Button margin=\"small\">Focus Me</Button>}\n          isShowingContent={isShowingContent}\n          onShowContent={() => {\n            setIsShowingContent(true)\n          }}\n          onHideContent={() => {\n            setIsShowingContent(false)\n          }}\n          on={['hover', 'focus']}\n          shouldContainFocus={false}\n          shouldFocusContentOnTriggerBlur={false}\n        >\n          <Button margin=\"small\">Focus Me When Trigger Blurs</Button>\n        </Popover>\n        <div id=\"container\" />\n        <Button id=\"next\" margin=\"small\">\n          Focus Me Next\n        </Button>\n      </div>\n    )\n  }\n\n  render(<Example />)\n  ```\n\n#### Custom elements as renderTrigger\n\nPopover and Tooltip attach mouse and focus event listeners to their `renderTrigger` components via props. These need to be propagated to the component for the listeners to work:\n\n- ```js\n  class MyComponent extends React.Component {\n    constructor(props) {\n      super(props)\n      this.ref = React.createRef()\n    }\n    render() {\n      //  Spread the props to the underlying DOM element\n      return (\n        <div {...this.props} ref={this.ref} style={{ width: '10rem' }}>\n          My custom component\n        </div>\n      )\n    }\n  }\n  ;<Popover renderTrigger={<MyComponent />}>\n    This text is wrapped by a Popover\n  </Popover>\n  ```\n\n- ```js\n  const MyComponent = React.forwardRef((props, ref) => {\n    return (\n      <div {...props} ref={ref} style={{ width: '10rem' }}>\n        My custom component\n      </div>\n    )\n  })\n\n  render(<MyComponent />)\n  ;<Popover renderTrigger={<MyComponent />}>\n    This text is wrapped by a Popover\n  </Popover>\n  ```\n\n#### Popover playground\n\n- ```js\n  class Example extends React.Component {\n    state = {\n      shouldAlignArrow: true,\n      isShowingContent: true,\n      withArrow: true,\n      placement: 'top',\n      shadow: 'topmost',\n      color: 'primary'\n    }\n    static placementsValues = [\n      'top',\n      'end',\n      'bottom',\n      'start',\n      'top start',\n      'start top',\n      'start center',\n      'start bottom',\n      'bottom start',\n      'bottom center',\n      'bottom end',\n      'end bottom',\n      'end center',\n      'end top',\n      'top end',\n      'top center',\n      'center end',\n      'center start'\n    ]\n    static shadowValues = ['none', 'resting', 'above', 'topmost']\n    changePlacement = (e, { value }) => this.setState({ placement: value })\n    changeShadow = (e, { value }) => this.setState({ shadow: value })\n    toggleWithArrow = (event) =>\n      this.setState({ withArrow: !this.state.withArrow })\n    toggleAlignArrow = (event) =>\n      this.setState({ shouldAlignArrow: !this.state.shouldAlignArrow })\n    toggleShowContent = (event) =>\n      this.setState({ isShowingContent: !this.state.isShowingContent })\n    changeColor = (event, value) => this.setState({ color: value })\n    render() {\n      return (\n        <View as=\"div\" background=\"primary\" padding=\"small\">\n          <Flex margin=\"small small large\" justifyItems=\"space-around\">\n            <Flex.Item align=\"start\">\n              <FormFieldGroup description=\"Popover Example\">\n                <Checkbox\n                  checked={this.state.isShowingContent}\n                  label=\"Show Content\"\n                  onChange={this.toggleShowContent}\n                />\n                <Checkbox\n                  checked={this.state.withArrow}\n                  label=\"With Arrow\"\n                  onChange={this.toggleWithArrow}\n                />\n                <Checkbox\n                  checked={this.state.shouldAlignArrow}\n                  label=\"Align Arrow\"\n                  onChange={this.toggleAlignArrow}\n                />\n              </FormFieldGroup>\n            </Flex.Item>\n            <Flex.Item>\n              <View as=\"div\" margin=\"none\" maxWidth=\"15rem\">\n                <SimpleSelect\n                  renderLabel=\"Placement\"\n                  value={this.state.placement}\n                  onChange={this.changePlacement}\n                >\n                  {Example.placementsValues.map((placement, index) => (\n                    <SimpleSelect.Option\n                      key={index}\n                      id={`${index}`}\n                      value={placement}\n                    >\n                      {placement}\n                    </SimpleSelect.Option>\n                  ))}\n                </SimpleSelect>\n              </View>\n              <View as=\"div\" margin=\"medium none\" maxWidth=\"15rem\">\n                <SimpleSelect\n                  value={this.state.shadow}\n                  onChange={this.changeShadow}\n                  renderLabel=\"Shadow\"\n                >\n                  {Example.shadowValues.map((shadow, index) => (\n                    <SimpleSelect.Option\n                      key={index}\n                      id={`${index}`}\n                      value={shadow}\n                    >\n                      {shadow}\n                    </SimpleSelect.Option>\n                  ))}\n                </SimpleSelect>\n              </View>\n            </Flex.Item>\n            <Flex.Item align=\"start\">\n              <View as=\"div\" margin=\"none\">\n                <RadioInputGroup\n                  name=\"changeColor\"\n                  defaultValue=\"primary\"\n                  description=\"Color:\"\n                  variant=\"toggle\"\n                  size=\"small\"\n                  onChange={this.changeColor}\n                >\n                  <RadioInput label=\"Primary\" value=\"primary\" />\n                  <RadioInput label=\"Primary inverse\" value=\"primary-inverse\" />\n                </RadioInputGroup>\n              </View>\n            </Flex.Item>\n          </Flex>\n          <View as=\"div\" display=\"block\" padding=\"large\" textAlign=\"center\">\n            <Popover\n              renderTrigger={\n                <div\n                  style={{\n                    display: 'inline-block',\n                    height: '3px',\n                    width: '3px',\n                    background: 'blue'\n                  }}\n                />\n              }\n              isShowingContent={this.state.isShowingContent}\n              placement={this.state.placement}\n              withArrow={this.state.withArrow}\n              shouldAlignArrow={this.state.shouldAlignArrow}\n              shadow={this.state.shadow}\n              color={this.state.color}\n            >\n              <Heading>\n                Small\n                <br />\n                Target\n              </Heading>\n            </Popover>\n          </View>\n        </View>\n      )\n    }\n  }\n\n  render(<Example />)\n  ```\n\n- ```js\n  const placementsValues = [\n    'top',\n    'end',\n    'bottom',\n    'start',\n    'top start',\n    'start top',\n    'start center',\n    'start bottom',\n    'bottom start',\n    'bottom center',\n    'bottom end',\n    'end bottom',\n    'end center',\n    'end top',\n    'top end',\n    'top center',\n    'center end',\n    'center start'\n  ]\n\n  const shadowValues = ['none', 'resting', 'above', 'topmost']\n\n  const Example = () => {\n    const [shouldAlignArrow, setShouldAlignArrow] = useState(true)\n    const [isShowingContent, setIsShowingContent] = useState(true)\n    const [withArrow, setWithArrow] = useState(true)\n    const [placement, setPlacement] = useState('top')\n    const [shadow, setShadow] = useState('topmost')\n    const [color, setColor] = useState('primary')\n\n    const changePlacement = (e, { value }) => {\n      setPlacement(value)\n    }\n\n    const changeShadow = (e, { value }) => {\n      setShadow(value)\n    }\n\n    const toggleWithArrow = () => {\n      setWithArrow((withArrow) => !withArrow)\n    }\n\n    const toggleAlignArrow = () => {\n      setShouldAlignArrow((shouldAlignArrow) => !shouldAlignArrow)\n    }\n\n    const toggleShowContent = () =>\n      setIsShowingContent((isShowingContent) => !isShowingContent)\n\n    const changeColor = (event, value) => {\n      setColor(value)\n    }\n\n    return (\n      <View as=\"div\" background=\"primary\" padding=\"small\">\n        <Flex margin=\"small small large\" justifyItems=\"space-around\">\n          <Flex.Item align=\"start\">\n            <FormFieldGroup description=\"Popover Example\">\n              <Checkbox\n                checked={isShowingContent}\n                label=\"Show Content\"\n                onChange={toggleShowContent}\n              />\n              <Checkbox\n                checked={withArrow}\n                label=\"With Arrow\"\n                onChange={toggleWithArrow}\n              />\n              <Checkbox\n                checked={shouldAlignArrow}\n                label=\"Align Arrow\"\n                onChange={toggleAlignArrow}\n              />\n            </FormFieldGroup>\n          </Flex.Item>\n          <Flex.Item>\n            <View as=\"div\" margin=\"none\" maxWidth=\"15rem\">\n              <SimpleSelect\n                renderLabel=\"Placement\"\n                value={placement}\n                onChange={changePlacement}\n              >\n                {placementsValues.map((placement, index) => (\n                  <SimpleSelect.Option\n                    key={index}\n                    id={`${index}`}\n                    value={placement}\n                  >\n                    {placement}\n                  </SimpleSelect.Option>\n                ))}\n              </SimpleSelect>\n            </View>\n            <View as=\"div\" margin=\"medium none\" maxWidth=\"15rem\">\n              <SimpleSelect\n                value={shadow}\n                onChange={changeShadow}\n                renderLabel=\"Shadow\"\n              >\n                {shadowValues.map((shadow, index) => (\n                  <SimpleSelect.Option\n                    key={index}\n                    id={`${index}`}\n                    value={shadow}\n                  >\n                    {shadow}\n                  </SimpleSelect.Option>\n                ))}\n              </SimpleSelect>\n            </View>\n          </Flex.Item>\n          <Flex.Item align=\"start\">\n            <View as=\"div\" margin=\"none\">\n              <RadioInputGroup\n                name=\"changeColor\"\n                defaultValue=\"primary\"\n                description=\"Color:\"\n                variant=\"toggle\"\n                size=\"small\"\n                onChange={changeColor}\n              >\n                <RadioInput label=\"Primary\" value=\"primary\" />\n                <RadioInput label=\"Primary inverse\" value=\"primary-inverse\" />\n              </RadioInputGroup>\n            </View>\n          </Flex.Item>\n        </Flex>\n        <View as=\"div\" display=\"block\" padding=\"large\" textAlign=\"center\">\n          <Popover\n            renderTrigger={\n              <div\n                style={{\n                  display: 'inline-block',\n                  height: '3px',\n                  width: '3px',\n                  background: 'blue'\n                }}\n              />\n            }\n            isShowingContent={isShowingContent}\n            placement={placement}\n            withArrow={withArrow}\n            shouldAlignArrow={shouldAlignArrow}\n            shadow={shadow}\n            color={color}\n          >\n            <Heading>\n              Small\n              <br />\n              Target\n            </Heading>\n          </Popover>\n        </View>\n      </View>\n    )\n  }\n\n  render(<Example />)\n  ```\n\n### Guidelines\n\n```js\n---\ntype: embed\n---\n<Guidelines>\n  <Figure recommendation=\"yes\" title=\"Do\">\n    <Figure.Item>Consider using a <Link href=\"/#Tray\">Tray</Link> if the content is beyond a mobile screen size</Figure.Item>\n  </Figure>\n  <Figure recommendation=\"no\" title=\"Don't\">\n    <Figure.Item>Put content on the same row as the close \"x\"</Figure.Item>\n    <Figure.Item>Use with an <Link href=\"#Overlay\">Overlay</Link></Figure.Item>\n    <Figure.Item>Have multiple Popovers open at the same time</Figure.Item>\n    <Figure.Item>Use in place of a <Link href=\"/#Tooltip\">Tooltip</Link> or <Link href=\"/#Menu\">Menu</Link></Figure.Item>\n  </Figure>\n</Guidelines>\n```\n\n```js\n---\ntype: embed\n---\n<Guidelines>\n  <Figure recommendation=\"a11y\" title=\"Accessibility\">\n    <Figure.Item>Keyboard focus must be set in the popover when it appears; usually on the first interactive element</Figure.Item>\n    <Figure.Item>Popovers must contain keyboard focus until they’re closed. This is to ensure that keyboard or screen reader users won't mistakenly interact with background content that is meant to be hidden or inaccessible</Figure.Item>\n    <Figure.Item>When a user closes the Popover, focus must return to a logical place within the page. This is usually the element that triggered opening the popover</Figure.Item>\n    <Figure.Item>Popovers should be able to be closed by clicking away, esc key and/or a close button</Figure.Item>\n  </Figure>\n</Guidelines>\n```\n","displayName":"Popover","methods":[],"props":{"isShowingContent":{"type":{"name":"bool"},"required":false,"description":"Whether or not the `<Popover />` content is shown","tsType":{"name":"boolean"}},"defaultIsShowingContent":{"type":{"name":"bool"},"required":false,"description":"Whether or not to show the content by default, when uncontrolled","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"on":{"type":{"name":"union","value":[{"name":"enum","value":[{"value":"'click'","computed":false},{"value":"'hover'","computed":false},{"value":"'focus'","computed":false}]},{"name":"arrayOf","value":{"name":"enum","value":[{"value":"'click'","computed":false},{"value":"'hover'","computed":false},{"value":"'focus'","computed":false}]}}]},"required":false,"description":"The action that causes the content to display (`click`, `hover`, `focus`)","tsType":{"name":"union","raw":"('click' | 'hover' | 'focus') | ('click' | 'hover' | 'focus')[]","elements":[{"name":"unknown"},{"name":"Array","elements":[{"name":"unknown"}],"raw":"('click' | 'hover' | 'focus')[]"}]},"defaultValue":{"value":"['hover', 'focus']","computed":false}},"withArrow":{"type":{"name":"bool"},"required":false,"description":"Whether or not an arrow pointing to the trigger should be rendered","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}},"color":{"type":{"name":"enum","value":[{"value":"'primary'","computed":false},{"value":"'primary-inverse'","computed":false}]},"required":false,"description":"Color variant of the popover content","tsType":{"name":"union","raw":"'primary' | 'primary-inverse'","elements":[{"name":"literal","value":"'primary'"},{"name":"literal","value":"'primary-inverse'"}]},"defaultValue":{"value":"'primary'","computed":false}},"placement":{"type":{"name":"custom","raw":"PositionPropTypes.placement"},"required":false,"description":"The placement of the content in relation to the trigger\n\nOne of: 'top', 'bottom', 'start', 'end', 'top start', 'top center',\n'top end', 'top stretch', 'bottom start', 'bottom center', 'bottom end',\n'bottom stretch', 'start top', 'start center', 'start bottom',\n'start stretch', 'end top', 'end center', 'end bottom', 'end stretch',\n'center start', 'center end', 'offscreen'","tsType":{"name":"PlacementPropValues"},"defaultValue":{"value":"'bottom center'","computed":false}},"shadow":{"type":{"name":"custom","raw":"ThemeablePropTypes.shadow"},"required":false,"description":"Controls the shadow depth for the `<Popover />`","tsType":{"name":"Shadow"},"defaultValue":{"value":"'resting'","computed":false}},"stacking":{"type":{"name":"custom","raw":"ThemeablePropTypes.stacking"},"required":false,"description":"Controls the z-index depth for the `<Popover />` content","tsType":{"name":"Stacking"},"defaultValue":{"value":"'topmost'","computed":false}},"contentRef":{"type":{"name":"func"},"required":false,"description":"A function that returns a reference to the content element","tsType":{"name":"signature","type":"function","raw":"(contentElement: Element | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"Element | null","elements":[{"name":"Element"},{"name":"null"}]},"name":"contentElement"}],"return":{"name":"void"}}}},"defaultFocusElement":{"type":{"name":"union","value":[{"name":"element"},{"name":"func"}]},"required":false,"description":"An element or a function returning an element to focus by default","tsType":{"name":"union","raw":"| Node\n| Window\n| ReactElement\n| Component\n| (() => Node | Window | null | undefined)\n| null","elements":[{"name":"Node"},{"name":"Window"},{"name":"ReactElement"},{"name":"Component"},{"name":"unknown"},{"name":"null"}]}},"screenReaderLabel":{"type":{"name":"string"},"required":false,"description":"An accessible label for the `<Popover />` content","tsType":{"name":"string"}},"offsetX":{"type":{"name":"union","value":[{"name":"string"},{"name":"number"}]},"required":false,"description":"The horizontal offset for the positioned content","tsType":{"name":"union","raw":"string | number","elements":[{"name":"string"},{"name":"number"}]},"defaultValue":{"value":"0","computed":false}},"offsetY":{"type":{"name":"union","value":[{"name":"string"},{"name":"number"}]},"required":false,"description":"The vertical offset for the positioned content","tsType":{"name":"union","raw":"string | number","elements":[{"name":"string"},{"name":"number"}]},"defaultValue":{"value":"0","computed":false}},"constrain":{"type":{"name":"custom","raw":"PositionPropTypes.constrain"},"required":false,"description":"The parent in which to constrain the popover.\n\nOne of: 'window', 'scroll-parent', 'parent', 'none', an element,\nor a function returning an element","tsType":{"name":"PositionConstraint"},"defaultValue":{"value":"'window'","computed":false}},"positionTarget":{"type":{"name":"union","value":[{"name":"element"},{"name":"func"}]},"required":false,"description":"Target element for positioning the Popover (if it differs from the trigger)","tsType":{"name":"PositionMountNode"}},"positionContainerDisplay":{"type":{"name":"enum","value":[{"value":"'inline-block'","computed":false},{"value":"'block'","computed":false}]},"required":false,"description":"Set the CSS `display` property on the `<span>` container element of the underlying Position component","tsType":{"name":"union","raw":"'inline-block' | 'block'","elements":[{"name":"literal","value":"'inline-block'"},{"name":"literal","value":"'block'"}]}},"mountNode":{"type":{"name":"custom","raw":"PositionPropTypes.mountNode"},"required":false,"description":"An element or a function returning an element to use as the mount node\nfor the `<Popover />` (defaults to `document.body`)","tsType":{"name":"PositionMountNode"}},"insertAt":{"type":{"name":"enum","value":[{"value":"'bottom'","computed":false},{"value":"'top'","computed":false}]},"required":false,"description":"Insert the element at the 'top' of the mountNode or at the 'bottom'","tsType":{"name":"union","raw":"'bottom' | 'top'","elements":[{"name":"literal","value":"'bottom'"},{"name":"literal","value":"'top'"}]},"defaultValue":{"value":"'bottom'","computed":false}},"liveRegion":{"type":{"name":"union","value":[{"name":"element"},{"name":"arrayOf","value":{"name":"element"}},{"name":"func"}]},"required":false,"description":"An element, function returning an element, or array of elements that will\nnot be hidden from the screen reader when the `<Popover />` is open","tsType":{"name":"union","raw":"| (() => (Element | null)[])\n| (() => Element | null)\n| (Element | null)[]\n| Element\n| null","elements":[{"name":"unknown"},{"name":"unknown"},{"name":"Array","elements":[{"name":"unknown"}],"raw":"(Element | null)[]"},{"name":"Element"},{"name":"null"}]}},"id":{"type":{"name":"string"},"required":false,"description":"An id is generated if not supplied.","tsType":{"name":"string"}},"shouldAlignArrow":{"type":{"name":"bool"},"required":false,"description":"Whether or not the content should offset to align by its arrow","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"shouldTrackPosition":{"type":{"name":"bool"},"required":false,"description":"Whether or not position should be tracked or just set on initial render","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}},"shouldRenderOffscreen":{"type":{"name":"bool"},"required":false,"description":"Should the `<Popover />` render offscreen when visually hidden","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"shouldContainFocus":{"type":{"name":"bool"},"required":false,"description":"Whether focus should contained within the `<Popover/>` when it is open","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"shouldReturnFocus":{"type":{"name":"bool"},"required":false,"description":"Whether focus should be returned to the trigger when the `<Popover/>` is closed","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}},"shouldCloseOnDocumentClick":{"type":{"name":"bool"},"required":false,"description":"Should the `<Popover />` hide when clicks occur outside the content","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}},"shouldCloseOnEscape":{"type":{"name":"bool"},"required":false,"description":"Should the `<Popover />` hide when the escape key is pressed","tsType":{"name":"boolean"},"defaultValue":{"value":"true","computed":false}},"shouldFocusContentOnTriggerBlur":{"type":{"name":"bool"},"required":false,"description":"Should the content become focused when the trigger is blurred","tsType":{"name":"boolean"},"defaultValue":{"value":"false","computed":false}},"onShowContent":{"type":{"name":"func"},"required":false,"description":"Callback fired when content is shown. When controlled, this callback is\nfired when the Popover expects to be shown","tsType":{"name":"signature","type":"function","raw":"(event: React.UIEvent | React.FocusEvent) => void","signature":{"arguments":[{"type":{"name":"union","raw":"React.UIEvent | React.FocusEvent","elements":[{"name":"ReactUIEvent","raw":"React.UIEvent"},{"name":"ReactFocusEvent","raw":"React.FocusEvent"}]},"name":"event"}],"return":{"name":"void"}}}},"onHideContent":{"type":{"name":"func"},"required":false,"description":"Callback fired when content is hidden. When controlled, this callback is\nfired when the Popover expects to be hidden","tsType":{"name":"signature","type":"function","raw":"(\n  event: React.UIEvent | React.FocusEvent,\n  args: { documentClick: boolean }\n) => void","signature":{"arguments":[{"type":{"name":"union","raw":"React.UIEvent | React.FocusEvent","elements":[{"name":"ReactUIEvent","raw":"React.UIEvent"},{"name":"ReactFocusEvent","raw":"React.FocusEvent"}]},"name":"event"},{"type":{"name":"signature","type":"object","raw":"{ documentClick: boolean }","signature":{"properties":[{"key":"documentClick","value":{"name":"boolean","required":true}}]}},"name":"args"}],"return":{"name":"void"}}}},"onPositioned":{"type":{"name":"func"},"required":false,"description":"Callback fired when content has been is initially positioned.\nIf `shouldRenderOffscreen` is true, it will only fire once, the first\ntime the content is shown","tsType":{"name":"signature","type":"function","raw":"(position: PositionObject) => void","signature":{"arguments":[{"type":{"name":"PositionObject"},"name":"position"}],"return":{"name":"void"}}}},"onPositionChanged":{"type":{"name":"func"},"required":false,"description":"Callback fired when the position changes","tsType":{"name":"signature","type":"function","raw":"(position: PositionObject) => void","signature":{"arguments":[{"type":{"name":"PositionObject"},"name":"position"}],"return":{"name":"void"}}}},"onClick":{"type":{"name":"func"},"required":false,"description":"Callback fired when component is clicked","tsType":{"name":"signature","type":"function","raw":"(event: React.MouseEvent) => void","signature":{"arguments":[{"type":{"name":"ReactMouseEvent","raw":"React.MouseEvent"},"name":"event"}],"return":{"name":"void"}}}},"onFocus":{"type":{"name":"func"},"required":false,"description":"Callback fired when trigger is focused","tsType":{"name":"signature","type":"function","raw":"(event: React.FocusEvent) => void","signature":{"arguments":[{"type":{"name":"ReactFocusEvent","raw":"React.FocusEvent"},"name":"event"}],"return":{"name":"void"}}}},"onBlur":{"type":{"name":"func"},"required":false,"description":"Callback fired when component is blurred","tsType":{"name":"signature","type":"function","raw":"(event: React.FocusEvent) => void","signature":{"arguments":[{"type":{"name":"ReactFocusEvent","raw":"React.FocusEvent"},"name":"event"}],"return":{"name":"void"}}}},"onKeyDown":{"type":{"name":"func"},"required":false,"description":"Callback fired on keydown","tsType":{"name":"signature","type":"function","raw":"(event: React.KeyboardEvent) => void","signature":{"arguments":[{"type":{"name":"ReactKeyboardEvent","raw":"React.KeyboardEvent"},"name":"event"}],"return":{"name":"void"}}}},"onKeyUp":{"type":{"name":"func"},"required":false,"description":"Callback fired on keyup","tsType":{"name":"signature","type":"function","raw":"(event: React.KeyboardEvent) => void","signature":{"arguments":[{"type":{"name":"ReactKeyboardEvent","raw":"React.KeyboardEvent"},"name":"event"}],"return":{"name":"void"}}}},"onMouseOver":{"type":{"name":"func"},"required":false,"description":"Callback fired when mouse is over trigger","tsType":{"name":"signature","type":"function","raw":"(event: React.MouseEvent) => void","signature":{"arguments":[{"type":{"name":"ReactMouseEvent","raw":"React.MouseEvent"},"name":"event"}],"return":{"name":"void"}}}},"onMouseOut":{"type":{"name":"func"},"required":false,"description":"Callback fired when mouse leaves trigger","tsType":{"name":"signature","type":"function","raw":"(event: React.MouseEvent) => void","signature":{"arguments":[{"type":{"name":"ReactMouseEvent","raw":"React.MouseEvent"},"name":"event"}],"return":{"name":"void"}}}},"renderTrigger":{"type":{"name":"union","value":[{"name":"node"},{"name":"func"}]},"required":false,"description":"The element that triggers the popover","tsType":{"name":"union","raw":"| keyof ReactHTML\n| keyof ReactSVG\n| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ReactHTML"},{"name":"ReactSVG"},{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}]}},"children":{"type":{"name":"union","value":[{"name":"node"},{"name":"func"}]},"required":false,"description":"The content to be shown by the popover","tsType":{"name":"union","raw":"| keyof ReactHTML\n| keyof ReactSVG\n| ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>\n| ComponentClass\n| ReactNode\n| ((data: P) => ReactNode | Element)\n| (() => ReactNode | Element)\n| Element","elements":[{"name":"ReactHTML"},{"name":"ReactSVG"},{"name":"ClassType","elements":[{"name":"P"},{"name":"ClassicComponent","elements":[{"name":"P"},{"name":"ComponentState"}],"raw":"ClassicComponent<P, ComponentState>"},{"name":"ClassicComponentClass","elements":[{"name":"P"}],"raw":"ClassicComponentClass<P>"}],"raw":"ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>"},{"name":"ComponentClass"},{"name":"ReactNode"},{"name":"unknown"},{"name":"unknown"},{"name":"Element"}]}},"elementRef":{"type":{"name":"func"},"required":false,"description":"Provides a reference to the underlying HTML root element","tsType":{"name":"signature","type":"function","raw":"(element: Element | null) => void","signature":{"arguments":[{"type":{"name":"union","raw":"Element | null","elements":[{"name":"Element"},{"name":"null"}]},"name":"element"}],"return":{"name":"void"}}}}},"category":"components","tags":"overlay, portal, dialog","relativePath":"packages/ui-popover/src/Popover/index.tsx","extension":".tsx","srcPath":"packages/ui-popover/src/Popover/index.tsx","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/packages/ui-popover/src/Popover/index.tsx","packageName":"@instructure/ui-popover","requirePath":"@instructure/ui-popover/lib/Popover/index","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/packages/ui-popover/src/Popover/index.tsx').default","esPath":"@instructure/ui-popover/es/Popover/index","id":"Popover","title":"Popover"}