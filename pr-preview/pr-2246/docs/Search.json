{"description":"\n## Search\n\nMake use of the following patterns when prompting users for a search query.\n\n### Auto Activated Search\n\nResults are updated in real time as the user keys in the search term.\n\n```js\n---\ntype: example\n---\nclass AutoActivatedSearchExample extends React.Component {\n  constructor (props) {\n    super(props)\n\n    this.state = {\n      value: '',\n      searchQuery: '',\n      isLoading: false,\n      results: []\n    }\n  }\n\n  timeoutId = null\n\n  handleChange = (e, value) => {\n    clearTimeout(this.timeoutId);\n\n    this.setState({\n      value,\n    })\n\n    this.loadResults(value)\n  }\n\n  loadResults = debounce((value) => {\n    if (!value || !value.length) {\n      this.setState({\n        searchQuery: value,\n        isLoading: false,\n        results: []\n      })\n\n      return;\n    }\n\n    this.setState({\n      isLoading: true,\n      searchQuery: value\n    })\n\n    this.timeoutId = setTimeout(() => {\n      const results = this.filterResults(value)\n\n      this.setState({\n        results,\n        isLoading: false\n      })\n    }, 1000)\n  }, 300)\n\n  filterResults = (query) => {\n    if (!query.length) {\n      return []\n    }\n\n    return this.props.dataset.filter(\n      ({label}) => label.toLowerCase().indexOf(query.toLowerCase()) > -1\n    )\n  }\n\n  handleClear = (e) => {\n    e.stopPropagation()\n    this.handleChange(e, \"\")\n    this.inputRef.focus()\n  }\n\n  renderClearButton = () => {\n    if (!this.state.value.length) return;\n\n    return (\n      <IconButton\n          type=\"button\"\n          size=\"small\"\n          withBackground={false}\n          withBorder={false}\n          screenReaderLabel=\"Clear search\"\n          disabled={this.state.disabled || this.state.readOnly}\n          onClick={this.handleClear}>\n        <IconTroubleLine />\n      </IconButton>\n    )\n  }\n\n  render () {\n    const {\n      results,\n      value,\n      searchQuery,\n      isLoading\n    } = this.state\n\n    return (\n      <View as=\"div\" padding=\"medium\">\n        <form\n           name=\"autoActivatedSearchExample\"\n           autoComplete=\"off\">\n          <TextInput\n            renderLabel={\n              <ScreenReaderContent>Search fruits</ScreenReaderContent>\n            }\n            placeholder=\"Search fruits...\"\n            value={value}\n            onChange={this.handleChange}\n            inputRef={(el) => this.inputRef = el}\n            renderBeforeInput={<IconSearchLine inline={false} />}\n            renderAfterInput={this.renderClearButton()}\n            shouldNotWrap\n          />\n        </form>\n        <View as=\"div\" padding=\"medium 0\">\n        {isLoading ? (\n          <Flex direction=\"column\" alignItems=\"center\" padding=\"large 0\">\n            <Spinner renderTitle=\"Loading\" />\n          </Flex>\n        ) : results.length ? (\n            <>\n              <View as=\"div\" margin=\"0 0 small\">\n                <Text color=\"secondary\">\n                  {results.length} {results.length > 1 ? 'results ' : 'result '}\n                  for \"{searchQuery}\"\n                </Text>\n              </View>\n              {results.map(({ id, label }) => (\n                <View\n                  key={id}\n                  as=\"div\"\n                  padding=\"small\"\n                  borderWidth=\"small none none none\"\n                >\n                  {label}\n                </View>\n              ))}\n              <Alert\n                liveRegion={() => document.getElementById('flash-messages')}\n                liveRegionPoliteness=\"assertive\"\n                screenReaderOnly\n              >\n                {`${results.length} ${results.length > 1 ? 'results' : 'result '} found`}\n              </Alert>\n            </>\n          ) : (\n            <Flex direction=\"column\" alignItems=\"center\" padding=\"large 0\">\n              <IconSearchLine size=\"medium\" color=\"secondary\" />\n              <View margin=\"small 0 0\">\n                <Text size=\"large\">\n                  { searchQuery.length ?\n                    `No results found for \"${searchQuery}\"` :\n                    \"Start typing to find results\"\n                  }\n                </Text>\n              </View>\n              <Alert\n                liveRegion={() => document.getElementById('flash-messages')}\n                liveRegionPoliteness=\"assertive\"\n                screenReaderOnly\n              >\n                No results found\n              </Alert>\n            </Flex>\n          )}\n        </View>\n      </View>\n    )\n  }\n}\n\nrender(\n  <AutoActivatedSearchExample dataset={[\n    {id: '0', label: 'Apple'},\n    {id: '1', label: 'Banana'},\n    {id: '2', label: 'Cherry'},\n    {id: '3', label: 'Grape'},\n    {id: '4', label: 'Mango'},\n    {id: '5', label: 'Orange'},\n    {id: '6', label: 'Pear'},\n    {id: '7', label: 'Plum'},\n    {id: '8', label: 'Watermelon'},\n  ]} />\n)\n```\n\n#### Guidelines\n\n```js\n---\ntype: embed\n---\n<Guidelines>\n  <Figure recommendation=\"yes\" title=\"Do\">\n    <Figure.Item>\n      Use a loading spinner or other loading animation in the results area to indicate data is being retrieved\n    </Figure.Item>\n    <Figure.Item>\n      Debounce user input and consider setting a minimum search string length to avoid extraneous requests\n    </Figure.Item>\n  </Figure>\n  <Figure recommendation=\"no\" title=\"Don't\">\n    <Figure.Item>\n      Use when long strings of text are needed to find useful results\n    </Figure.Item>\n  </Figure>\n</Guidelines>\n```\n\n### Activated Search\n\nResults are updated when a user triggers the search action, via keyboard or\nmouse.\n\n```js\n---\ntype: example\n---\nclass ActivatedSearchExample extends React.Component {\n  constructor (props) {\n    super(props)\n\n    this.state = {\n      value: '',\n      submittedValue: '',\n      results: []\n    }\n  }\n\n  timeoutId = null\n\n  handleChange = (e, value) => this.setState({ value })\n\n  handleClear = (e) => {\n    e.stopPropagation()\n    this.handleChange(e, \"\")\n    this.inputRef.focus()\n  }\n\n  handleSearch = (e) => {\n    const { value } = this.state\n\n    clearTimeout(this.timeoutId);\n\n    if (!value.length) {\n      return\n    }\n\n    this.setState({\n      isLoading: true,\n      submittedValue: value\n    })\n\n    this.timeoutId = setTimeout(() => {\n      const results = this.props.dataset.filter(\n        ({label}) => label.toLowerCase().indexOf(value.toLowerCase()) > -1\n      )\n\n      this.setState({\n        results,\n        isLoading: false\n      })\n    }, 1000)\n  }\n\n  renderClearButton = () => {\n    if (!this.state.value.length) return;\n\n    return (\n      <IconButton\n          type=\"button\"\n          size=\"small\"\n          withBackground={false}\n          withBorder={false}\n          screenReaderLabel=\"Clear search\"\n          disabled={this.state.disabled || this.state.readOnly}\n          onClick={this.handleClear}>\n        <IconTroubleLine />\n      </IconButton>\n    )\n  }\n\n  render () {\n    const {\n      results,\n      submittedValue,\n      value,\n      isLoading\n    } = this.state\n\n    return (\n      <View as=\"div\" padding=\"medium\">\n        <form\n           name=\"activatedSearchExample\"\n           onSubmit={this.handleSearch}\n           autoComplete=\"off\">\n          <Flex>\n            <Flex.Item shouldGrow>\n              <TextInput\n                renderLabel={\n                  <ScreenReaderContent>Search fruits</ScreenReaderContent>\n                }\n                placeholder=\"Search fruits...\"\n                value={value}\n                onChange={this.handleChange}\n                inputRef={(el) => this.inputRef = el}\n                renderBeforeInput={<IconSearchLine inline={false} />}\n                renderAfterInput={this.renderClearButton()}\n                shouldNotWrap\n              />\n            </Flex.Item>\n            <Flex.Item>\n              <Button\n                 color=\"primary\"\n                 margin=\"0 0 0 small\"\n                 onClick={this.handleSearch}>\n                Search\n              </Button>\n            </Flex.Item>\n          </Flex>\n        </form>\n        <View as=\"div\" padding=\"medium 0 0\">\n          {isLoading ? (\n            <Flex direction=\"column\" alignItems=\"center\" padding=\"large 0\">\n              <Spinner renderTitle=\"Loading\" />\n            </Flex>\n          ) : submittedValue.length ? results.length ? (\n            <>\n              <View as=\"div\" margin=\"0 0 small\">\n                <Text color=\"secondary\">\n                  {results.length} {results.length > 1 ? 'results ' : 'result '}\n                  for \"{submittedValue}\"\n                </Text>\n              </View>\n              {results.map(({ id, label }) => (\n                <View\n                  key={id}\n                  as=\"div\"\n                  padding=\"small\"\n                  borderWidth=\"small none none none\"\n                >\n                  {label}\n                </View>\n              ))}\n              <Alert\n                liveRegion={() => document.getElementById('flash-messages')}\n                liveRegionPoliteness=\"assertive\"\n                screenReaderOnly\n              >\n                {`${results.length} ${results.length > 1 ? 'results' : 'result '} found`}\n              </Alert>\n            </>\n          ) : (\n            <>\n              <span>No results found for \"{submittedValue}\".</span>\n              <Alert\n                liveRegion={() => document.getElementById('flash-messages')}\n                liveRegionPoliteness=\"assertive\"\n                screenReaderOnly\n              >\n                No results found\n              </Alert>\n            </>\n          ) : null }\n        </View>\n      </View>\n    )\n  }\n}\n\nrender(\n  <ActivatedSearchExample dataset={[\n    {id: '0', label: 'Apple'},\n    {id: '1', label: 'Banana'},\n    {id: '2', label: 'Cherry'},\n    {id: '3', label: 'Grape'},\n    {id: '4', label: 'Mango'},\n    {id: '5', label: 'Orange'},\n    {id: '6', label: 'Pear'},\n    {id: '7', label: 'Plum'},\n    {id: '8', label: 'Watermelon'},\n  ]} />\n)\n```\n\n#### Guidelines\n\n```js\n---\ntype: embed\n---\n<Guidelines>\n  <Figure recommendation=\"yes\" title=\"Do\">\n    <Figure.Item>\n      Use a loading spinner or other loading animation in the results area after the “Search” action has been triggered\n    </Figure.Item>\n  </Figure>\n</Guidelines>\n```\n\n### Autocomplete Results\n\nSearch performed within an autocomplete is used to populate the form field.\nIf the desired result is not found, no action is ultimately taken with this\npattern. It can be used for a single select, or a multi-select with tags. A\nsearch icon may or may not be used on the left, depending on the context.\n\n```js\n---\ntype: example\n---\n\nclass AutocompleteExample extends React.Component {\n  state = {\n    inputValue: '',\n    isShowingOptions: false,\n    highlightedOptionId: null,\n    selectedOptionId: null,\n    filteredOptions: this.props.dataset,\n    announcement: null\n  }\n\n  getOptionById (queryId) {\n    return this.props.dataset.find(({ id }) => id === queryId)\n  }\n\n  getOptionsChangedMessage (newOptions) {\n    let message = newOptions.length !== this.state.filteredOptions.length\n      ? `${newOptions.length} options available.` // options changed, announce new total\n      : null // options haven't changed, don't announce\n    if (message && newOptions.length > 0) {\n      // options still available\n      if (this.state.highlightedOptionId !== newOptions[0].id) {\n        // highlighted option hasn't been announced\n        const option = this.getOptionById(newOptions[0].id).label\n        message = `${option}. ${message}`\n      }\n    }\n    return message\n  }\n\n  filterOptions = (value) => {\n    return this.props.dataset.filter(option => (\n      option.label.toLowerCase().startsWith(value.toLowerCase())\n    ))\n  }\n\n  matchValue () {\n    const {\n      filteredOptions,\n      inputValue,\n      highlightedOptionId,\n      selectedOptionId\n    } = this.state\n\n    // an option matching user input exists\n    if (filteredOptions.length === 1) {\n      const onlyOption = filteredOptions[0]\n      // automatically select the matching option\n      if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {\n        return {\n          inputValue: onlyOption.label,\n          selectedOptionId: onlyOption.id,\n          filteredOptions: this.filterOptions('')\n        }\n      }\n    }\n    // allow user to return to empty input and no selection\n    if (inputValue.length === 0) {\n      return { selectedOptionId: null }\n    }\n    // no match found, return selected option label to input\n    if (selectedOptionId) {\n      const selectedOption = this.getOptionById(selectedOptionId)\n      return { inputValue: selectedOption.label }\n    }\n    // input value is from highlighted option, not user input\n    // clear input, reset options\n    if (highlightedOptionId) {\n      if (inputValue === this.getOptionById(highlightedOptionId).label) {\n        return {\n          inputValue: '',\n          filteredOptions: this.filterOptions('')\n        }\n      }\n    }\n  }\n\n  handleShowOptions = (event) => {\n    this.setState(({ filteredOptions }) => ({\n      isShowingOptions: true,\n      announcement: `List expanded. ${filteredOptions.length} options available.`\n    }))\n  }\n\n  handleHideOptions = (event) => {\n    const { selectedOptionId, inputValue } = this.state\n    this.setState({\n      isShowingOptions: false,\n      highlightedOptionId: null,\n      announcement: 'List collapsed.',\n      ...this.matchValue()\n    })\n  }\n\n  handleBlur = (event) => {\n    this.setState({ highlightedOptionId: null })\n  }\n\n  handleHighlightOption = (event, { id }) => {\n    event.persist()\n    const option = this.getOptionById(id)\n    if (!option) return // prevent highlighting of empty option\n    this.setState((state) => ({\n      highlightedOptionId: id,\n      inputValue: event.type === 'keydown' ? option.label : state.inputValue,\n      announcement: option.label\n    }))\n  }\n\n  handleSelectOption = (event, { id }) => {\n    const option = this.getOptionById(id)\n    if (!option) return // prevent selecting of empty option\n    this.setState({\n      selectedOptionId: id,\n      inputValue: option.label,\n      isShowingOptions: false,\n      filteredOptions: this.props.dataset,\n      announcement: `${option.label} selected. List collapsed.`\n    })\n  }\n\n  handleInputChange = (event) => {\n    const value = event.target.value\n    const newOptions = this.filterOptions(value)\n    this.setState((state) => ({\n      inputValue: value,\n      filteredOptions: newOptions,\n      highlightedOptionId: newOptions.length > 0 ? newOptions[0].id : null,\n      isShowingOptions: true,\n      selectedOptionId: value === '' ? null : state.selectedOptionId,\n      announcement: this.getOptionsChangedMessage(newOptions)\n    }))\n  }\n\n  handleClearInput = (event) => {\n    this.setState({\n      isShowingOptions: false,\n      isLoading: false,\n      highlightedOptionId: null,\n      selectedOptionId: null,\n      selectedOptionLabel: '',\n      filteredOptions: [],\n      announcement: 'List collapsed.',\n      inputValue: ''\n    })\n  }\n\n  renderAfterInput = () => {\n    if (!this.state.inputValue.length) {\n      return null\n    }\n\n    return (\n      <IconButton\n          type=\"button\"\n          size=\"small\"\n          withBackground={false}\n          withBorder={false}\n          screenReaderLabel=\"Clear search\"\n          onClick={this.handleClearInput}>\n        <IconTroubleLine />\n      </IconButton>\n    )\n  }\n\n  render () {\n    const {\n      inputValue,\n      isShowingOptions,\n      highlightedOptionId,\n      selectedOptionId,\n      filteredOptions,\n      announcement\n    } = this.state\n\n    return (\n      <View as=\"div\" padding=\"medium\">\n        <Select\n          renderLabel=\"What's your favorite fruit?\"\n          assistiveText=\"Type or use arrow keys to navigate options.\"\n          placeholder=\"Start typing to search...\"\n          inputValue={inputValue}\n          isShowingOptions={isShowingOptions}\n          onBlur={this.handleBlur}\n          onInputChange={this.handleInputChange}\n          onRequestShowOptions={this.handleShowOptions}\n          onRequestHideOptions={this.handleHideOptions}\n          onRequestHighlightOption={this.handleHighlightOption}\n          onRequestSelectOption={this.handleSelectOption}\n          renderBeforeInput={<IconSearchLine inline={false} />}\n          renderAfterInput={this.renderAfterInput()}\n          shouldNotWrap\n        >\n          {filteredOptions.length > 0 ? filteredOptions.map((option) => {\n            return (\n              <Select.Option\n                id={option.id}\n                key={option.id}\n                isHighlighted={option.id === highlightedOptionId}\n                isSelected={option.id === selectedOptionId}\n                isDisabled={option.disabled}\n              >\n                {option.label}\n              </Select.Option>\n            )\n          }) : (\n            <Select.Option\n              id=\"empty-option\"\n              key=\"empty-option\"\n            >\n              No results found\n            </Select.Option>\n          )}\n        </Select>\n        <Alert\n          liveRegion={() => document.getElementById('flash-messages')}\n          liveRegionPoliteness=\"assertive\"\n          screenReaderOnly\n        >\n          { announcement }\n        </Alert>\n      </View>\n    )\n  }\n}\n\nrender(\n  <View>\n    <AutocompleteExample dataset={[\n      {id: '0', label: 'Apple'},\n      {id: '1', label: 'Banana'},\n      {id: '2', label: 'Cherry'},\n      {id: '3', label: 'Grape'},\n      {id: '4', label: 'Mango'},\n      {id: '5', label: 'Orange'},\n      {id: '6', label: 'Pear'},\n      {id: '7', label: 'Plum'},\n      {id: '8', label: 'Watermelon'},\n    ]} />\n  </View>\n)\n```\n\n#### Guidelines\n\n```js\n---\ntype: embed\n---\n<Guidelines>\n  <Figure recommendation=\"yes\" title=\"Do\">\n    <Figure.Item>\n      Provide additional information when no results are found (e.g. \"Sorry, no matches were found”, “No results found”, “User not found”)\n    </Figure.Item>\n    <Figure.Item>\n      Use a loading spinner if autocomplete results are being retrieved asynchronously\n    </Figure.Item>\n  </Figure>\n</Guidelines>\n```\n\n### Search Input\n\nUse this reference to see how various states affect how the search input is\nrendered.\n\n```js\n---\ntype: example\n---\nclass SearchInputExample extends React.Component {\n  constructor (props) {\n    super(props)\n\n    this.state = {\n      size: 'medium',\n      value: '',\n      disabled: false,\n      readOnly: false,\n      inline: false,\n    }\n  }\n\n  handleChange = (e, value) => this.setState({ value })\n\n  handleClear = (e) => {\n    e.stopPropagation()\n    this.handleChange(e, \"\")\n    this.inputRef.focus()\n  }\n\n  toggleDisabled = (e) => this.setState(({ disabled: !this.state.disabled }))\n  toggleReadOnly = (e) => this.setState(({ readOnly: !this.state.readOnly }))\n  toggleInline = (e) => this.setState(({ inline: !this.state.inline }))\n  toggleSize = (e, value) => this.setState(({ size: value }))\n\n  renderClearButton = () => {\n    if (!this.state.value.length) return;\n    if (this.state.readOnly || this.state.disabled) return;\n\n    return (\n      <IconButton\n          type=\"button\"\n          size=\"small\"\n          withBackground={false}\n          withBorder={false}\n          screenReaderLabel=\"Clear search\"\n          disabled={this.state.disabled || this.state.readOnly}\n          onClick={this.handleClear}>\n        <IconTroubleLine />\n      </IconButton>\n    )\n  }\n\n  render () {\n    return (\n      <View as=\"div\" padding=\"medium\">\n        <View\n          display=\"block\"\n          margin=\"0 0 medium\"\n          padding=\"0 0 medium\"\n          borderWidth=\"none none small none\"\n        >\n          <TextInput\n            size={this.state.size}\n            renderLabel=\"What are you looking for?\"\n            display={this.state.inline ? 'inline-block' : null}\n            value={this.state.value}\n            onChange={this.handleChange}\n            interaction={this.state.disabled\n              ? 'disabled'\n              : this.state.readOnly ? 'readonly' : 'enabled'\n            }\n            inputRef={(el) => this.inputRef = el}\n            renderBeforeInput={<IconSearchLine inline={false} />}\n            renderAfterInput={this.renderClearButton()}\n            shouldNotWrap\n          />\n        </View>\n        <FormFieldGroup\n          description=\"TextInput Options\"\n          layout=\"inline\"\n        >\n          <Checkbox\n            checked={this.state.disabled}\n            label=\"Disabled\"\n            onChange={this.toggleDisabled}\n          />\n          <Checkbox\n            checked={this.state.readOnly}\n            label=\"Read-Only\"\n            onChange={this.toggleReadOnly}\n          />\n          <Checkbox\n            checked={this.state.inline}\n            label=\"Inline Display\"\n            onChange={this.toggleInline}\n          />\n          <RadioInputGroup\n            layout=\"columns\"\n            name=\"size\"\n            defaultValue=\"medium\"\n            description={<ScreenReaderContent>Input size</ScreenReaderContent>}\n            onChange={this.toggleSize}\n          >\n            <RadioInput value=\"medium\" label=\"Medium\" />\n            <RadioInput value=\"large\" label=\"Large\" />\n          </RadioInputGroup>\n        </FormFieldGroup>\n      </View>\n    )\n  }\n}\n\nrender(<SearchInputExample />)\n```\n\n#### Guidelines\n\n```js\n---\ntype: embed\n---\n<Guidelines>\n  <Figure recommendation=\"yes\" title=\"Do\">\n    <Figure.Item>\n      Include an IconButton that clears the current search query\n    </Figure.Item>\n    <Figure.Item>Use the \"trouble\" icon for the clear action</Figure.Item>\n    <Figure.Item>\n      Restore focus to the search input after clearing its value\n    </Figure.Item>\n  </Figure>\n  <Figure recommendation=\"no\" title=\"Don't\">\n    <Figure.Item>\n      Show the IconButton when there is no search query, or when the search\n      input is disabled or read-only\n    </Figure.Item>\n    <Figure.Item>Use the \"end\" or \"X\" icons for the clear action</Figure.Item>\n    <Figure.Item>Use a size \"small\" TextInput</Figure.Item>\n  </Figure>\n</Guidelines>\n```\n","title":"Search","category":"Patterns","id":"Search","relevantForAI":true,"relativePath":"docs/patterns/Search.md","extension":".md","srcPath":"docs/patterns/Search.md","srcUrl":"https://github.com/instructure/instructure-ui/tree/master/docs/patterns/Search.md","packageName":"@instructure/docs","requirePath":"@instructure/docs/patterns/Search","requireStr":"require('/home/runner/work/instructure-ui/instructure-ui/docs/patterns/Search.md').default","esPath":"@instructure/docs/patterns/Search","themePath":"docs/patterns/Search.md","themeUrl":"https://github.com/instructure/instructure-ui/tree/master/docs/patterns/Search.md"}